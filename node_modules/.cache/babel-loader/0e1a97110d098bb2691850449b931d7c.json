{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.GraphQLSchema = void 0;\nexports.assertSchema = assertSchema;\nexports.isSchema = isSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _instanceOf = require('../jsutils/instanceOf.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _toObjMap = require('../jsutils/toObjMap.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n\nfunction isSchema(schema) {\n  return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);\n}\n\nfunction assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\n\n\nclass GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives; // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `\"types\" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);\n    !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, '\"directives\" must be Array if provided but got: ' + `${(0, _inspect.inspect)(config.directives)}.`);\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if ((0, _directives.isDirective)(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(_introspection.__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName || (0, _devAssert.devAssert)(false, 'One of the provided types for building the Schema is missing a name.');\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(`Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`);\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if ((0, _definition.isInterfaceType)(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if ((0, _definition.isObjectType)(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case _ast.OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case _ast.OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case _ast.OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if ((0, _definition.isUnionType)(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find(directive => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined\n    };\n  }\n\n}\n\nexports.GraphQLSchema = GraphQLSchema;\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = (0, _definition.getNamedType)(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if ((0, _definition.isUnionType)(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if ((0, _definition.isInputObjectType)(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/type/schema.js"],"names":["Object","defineProperty","exports","value","GraphQLSchema","assertSchema","isSchema","_devAssert","require","_inspect","_instanceOf","_isObjectLike","_toObjMap","_ast","_definition","_directives","_introspection","schema","instanceOf","Error","inspect","constructor","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","isObjectLike","devAssert","types","Array","isArray","directives","description","extensions","toObjMap","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","specifiedDirectives","allReferencedTypes","Set","type","delete","collectReferencedTypes","directive","isDirective","arg","args","__Schema","_typeMap","create","_subTypeMap","_implementationsMap","namedType","typeName","name","isInterfaceType","iface","getInterfaces","implementations","objects","interfaces","push","isObjectType","Symbol","toStringTag","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","OperationTypeNode","QUERY","MUTATION","SUBSCRIPTION","getTypeMap","getType","getPossibleTypes","abstractType","isUnionType","getTypes","getImplementations","interfaceType","isSubType","maybeSubType","map","getDirectives","getDirective","find","toConfig","values","typeSet","getNamedType","has","add","memberType","field","getFields","isInputObjectType"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.GraphQLSchema = void 0;\nexports.assertSchema = assertSchema;\nexports.isSchema = isSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _instanceOf = require('../jsutils/instanceOf.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _toObjMap = require('../jsutils/toObjMap.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\n/**\n * Test if the given value is a GraphQL schema.\n */\nfunction isSchema(schema) {\n  return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);\n}\n\nfunction assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`,\n    );\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nclass GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    (0, _isObjectLike.isObjectLike)(config) ||\n      (0, _devAssert.devAssert)(false, 'Must provide configuration object.');\n    !config.types ||\n      Array.isArray(config.types) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `\"types\" must be Array if provided but got: ${(0, _inspect.inspect)(\n          config.types,\n        )}.`,\n      );\n    !config.directives ||\n      Array.isArray(config.directives) ||\n      (0, _devAssert.devAssert)(\n        false,\n        '\"directives\" must be Array if provided but got: ' +\n          `${(0, _inspect.inspect)(config.directives)}.`,\n      );\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives =\n      (_config$directives = config.directives) !== null &&\n      _config$directives !== void 0\n        ? _config$directives\n        : _directives.specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if ((0, _directives.isDirective)(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(_introspection.__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName ||\n        (0, _devAssert.devAssert)(\n          false,\n          'One of the provided types for building the Schema is missing a name.',\n        );\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if ((0, _definition.isInterfaceType)(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if ((0, _definition.isObjectType)(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case _ast.OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case _ast.OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case _ast.OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return (0, _definition.isUnionType)(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0\n      ? implementations\n      : {\n          objects: [],\n          interfaces: [],\n        };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if ((0, _definition.isUnionType)(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined,\n    };\n  }\n}\n\nexports.GraphQLSchema = GraphQLSchema;\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = (0, _definition.getNamedType)(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if ((0, _definition.isUnionType)(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (\n      (0, _definition.isObjectType)(namedType) ||\n      (0, _definition.isInterfaceType)(namedType)\n    ) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if ((0, _definition.isInputObjectType)(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"]},"metadata":{},"sourceType":"script"}