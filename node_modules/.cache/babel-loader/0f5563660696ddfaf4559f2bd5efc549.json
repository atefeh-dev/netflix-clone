{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _TypeInfo = require('../utilities/TypeInfo.js');\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\n\n\nclass ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while (set = setsToVisit.pop()) {\n        for (const selection of set.selections) {\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while (node = nodesToVisit.pop()) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n\n}\n\nexports.ASTValidationContext = ASTValidationContext;\n\nclass SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n}\n\nexports.SDLValidationContext = SDLValidationContext;\n\nclass ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {\n        VariableDefinition: () => false,\n\n        Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n\n}\n\nexports.ValidationContext = ValidationContext;","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/ValidationContext.js"],"names":["Object","defineProperty","exports","value","ValidationContext","SDLValidationContext","ASTValidationContext","_kinds","require","_visitor","_TypeInfo","constructor","ast","onError","_ast","_fragments","undefined","_fragmentSpreads","Map","_recursivelyReferencedFragments","_onError","Symbol","toStringTag","reportError","error","getDocument","getFragment","name","fragments","create","defNode","definitions","kind","Kind","FRAGMENT_DEFINITION","getFragmentSpreads","node","spreads","get","setsToVisit","set","pop","selection","selections","FRAGMENT_SPREAD","push","selectionSet","getRecursivelyReferencedFragments","operation","collectedNames","nodesToVisit","spread","fragName","fragment","schema","_schema","getSchema","typeInfo","_typeInfo","_variableUsages","_recursiveVariableUsages","getVariableUsages","usages","newUsages","TypeInfo","visit","visitWithTypeInfo","VariableDefinition","Variable","variable","type","getInputType","defaultValue","getDefaultValue","getRecursiveVariableUsages","frag","concat","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument","getEnumValue"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ValidationContext =\n  exports.SDLValidationContext =\n  exports.ASTValidationContext =\n    void 0;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _TypeInfo = require('../utilities/TypeInfo.js');\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nclass ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\n\nexports.ASTValidationContext = ASTValidationContext;\n\nclass SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\n\nexports.SDLValidationContext = SDLValidationContext;\n\nclass ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(\n        node,\n        (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n\nexports.ValidationContext = ValidationContext;\n"]},"metadata":{},"sourceType":"script"}