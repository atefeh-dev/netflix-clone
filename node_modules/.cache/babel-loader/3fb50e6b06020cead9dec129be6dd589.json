{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.TypeInfo = void 0;\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _typeFromAST = require('./typeFromAST.js');\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\n\nclass TypeInfo {\n  constructor(schema,\n  /**\n   * Initial type may be provided in rare cases to facilitate traversals\n   *  beginning somewhere other than documents.\n   */\n  initialType,\n  /** @deprecated will be removed in 17.0.0 */\n  getFieldDefFn) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        {\n          const namedType = (0, _definition.getNamedType)(this.getType());\n\n          this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.FIELD:\n        {\n          const parentType = this.getParentType();\n          let fieldDef;\n          let fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n        {\n          const rootType = schema.getRootType(node.operation);\n\n          this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        {\n          const typeConditionAST = node.typeCondition;\n          const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());\n\n          this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        {\n          const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          let argDef;\n          let argType;\n          const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = fieldOrDirective.args.find(arg => arg.name === node.name.value);\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.LIST:\n        {\n          const listType = (0, _definition.getNullableType)(this.getInputType());\n          const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.OBJECT_FIELD:\n        {\n          const objectType = (0, _definition.getNamedType)(this.getInputType());\n          let inputFieldType;\n          let inputField;\n\n          if ((0, _definition.isInputObjectType)(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.ENUM:\n        {\n          const enumType = (0, _definition.getNamedType)(this.getInputType());\n          let enumValue;\n\n          if ((0, _definition.isEnumType)(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n\n      default: // Ignore other nodes\n\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n\n    }\n  }\n\n}\n\nexports.TypeInfo = TypeInfo;\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      const node = args[0];\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/TypeInfo.js"],"names":["Object","defineProperty","exports","value","TypeInfo","visitWithTypeInfo","_ast","require","_kinds","_visitor","_definition","_introspection","_typeFromAST","constructor","schema","initialType","getFieldDefFn","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","isInputType","push","isCompositeType","isOutputType","Symbol","toStringTag","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","Kind","SELECTION_SET","namedType","getNamedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","OPERATION_DEFINITION","rootType","getRootType","operation","isObjectType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","typeFromAST","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","find","arg","defaultValue","LIST","listType","getNullableType","itemType","isListType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","isInputObjectType","getFields","ENUM","enumType","enumValue","isEnumType","getValue","leave","pop","fieldNode","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","isInterfaceType","typeInfo","visitor","fn","getEnterLeaveForKind","result","apply","isNode"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.TypeInfo = void 0;\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _typeFromAST = require('./typeFromAST.js');\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nclass TypeInfo {\n  constructor(\n    schema,\n    /**\n     * Initial type may be provided in rare cases to facilitate traversals\n     *  beginning somewhere other than documents.\n     */\n    initialType,\n    /** @deprecated will be removed in 17.0.0 */\n    getFieldDefFn,\n  ) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef =\n      getFieldDefFn !== null && getFieldDefFn !== void 0\n        ? getFieldDefFn\n        : getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET: {\n        const namedType = (0, _definition.getNamedType)(this.getType());\n\n        this._parentTypeStack.push(\n          (0, _definition.isCompositeType)(namedType) ? namedType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.FIELD: {\n        const parentType = this.getParentType();\n        let fieldDef;\n        let fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(\n          (0, _definition.isOutputType)(fieldType) ? fieldType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION: {\n        const rootType = schema.getRootType(node.operation);\n\n        this._typeStack.push(\n          (0, _definition.isObjectType)(rootType) ? rootType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION: {\n        const typeConditionAST = node.typeCondition;\n        const outputType = typeConditionAST\n          ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST)\n          : (0, _definition.getNamedType)(this.getType());\n\n        this._typeStack.push(\n          (0, _definition.isOutputType)(outputType) ? outputType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.VARIABLE_DEFINITION: {\n        const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(inputType) ? inputType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.ARGUMENT: {\n        var _this$getDirective;\n\n        let argDef;\n        let argType;\n        const fieldOrDirective =\n          (_this$getDirective = this.getDirective()) !== null &&\n          _this$getDirective !== void 0\n            ? _this$getDirective\n            : this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = fieldOrDirective.args.find(\n            (arg) => arg.name === node.name.value,\n          );\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(argType) ? argType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.LIST: {\n        const listType = (0, _definition.getNullableType)(this.getInputType());\n        const itemType = (0, _definition.isListType)(listType)\n          ? listType.ofType\n          : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(itemType) ? itemType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.OBJECT_FIELD: {\n        const objectType = (0, _definition.getNamedType)(this.getInputType());\n        let inputFieldType;\n        let inputField;\n\n        if ((0, _definition.isInputObjectType)(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(\n          inputField ? inputField.defaultValue : undefined,\n        );\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(inputFieldType)\n            ? inputFieldType\n            : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.ENUM: {\n        const enumType = (0, _definition.getNamedType)(this.getInputType());\n        let enumValue;\n\n        if ((0, _definition.isEnumType)(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n      }\n\n      default: // Ignore other nodes\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n    }\n  }\n}\n\nexports.TypeInfo = TypeInfo;\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (\n    name === _introspection.SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (\n    name === _introspection.TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (\n    name === _introspection.TypeNameMetaFieldDef.name &&\n    (0, _definition.isCompositeType)(parentType)\n  ) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if (\n    (0, _definition.isObjectType)(parentType) ||\n    (0, _definition.isInterfaceType)(parentType)\n  ) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(...args) {\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(...args) {\n      const node = args[0];\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}