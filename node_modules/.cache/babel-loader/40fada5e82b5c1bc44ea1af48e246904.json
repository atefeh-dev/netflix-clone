{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.KnownTypeNamesRule = KnownTypeNamesRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _introspection = require('../../type/introspection.js');\n\nvar _scalars = require('../../type/scalars.js');\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\n\n\nfunction KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [...Object.keys(existingTypesMap), ...Object.keys(definedTypes)];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new _GraphQLError.GraphQLError(`Unknown type \"${typeName}\".` + (0, _didYouMean.didYouMean)(suggestedTypes), {\n          nodes: node\n        }));\n      }\n    }\n\n  };\n}\n\nconst standardTypeNames = [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes].map(type => type.name);\n\nfunction isSDLNode(value) {\n  return 'kind' in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"],"names":["Object","defineProperty","exports","value","KnownTypeNamesRule","_didYouMean","require","_suggestionList","_GraphQLError","_predicates","_introspection","_scalars","context","schema","getSchema","existingTypesMap","getTypeMap","create","definedTypes","def","getDocument","definitions","isTypeDefinitionNode","name","typeNames","keys","NamedType","node","_1","parent","_2","ancestors","typeName","_ancestors$","definitionNode","isSDL","isSDLNode","standardTypeNames","includes","suggestedTypes","suggestionList","concat","reportError","GraphQLError","didYouMean","nodes","specifiedScalarTypes","introspectionTypes","map","type","isTypeSystemDefinitionNode","isTypeSystemExtensionNode"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownTypeNamesRule = KnownTypeNamesRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _introspection = require('../../type/introspection.js');\n\nvar _scalars = require('../../type/scalars.js');\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nfunction KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = (0, _suggestionList.suggestionList)(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Unknown type \"${typeName}\".` +\n              (0, _didYouMean.didYouMean)(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nconst standardTypeNames = [\n  ..._scalars.specifiedScalarTypes,\n  ..._introspection.introspectionTypes,\n].map((type) => type.name);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    ((0, _predicates.isTypeSystemDefinitionNode)(value) ||\n      (0, _predicates.isTypeSystemExtensionNode)(value))\n  );\n}\n"]},"metadata":{},"sourceType":"script"}