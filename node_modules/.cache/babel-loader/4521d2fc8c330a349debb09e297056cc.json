{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.NoFragmentCyclesRule = NoFragmentCyclesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\n\n\nfunction NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath.slice(0, -1).map(s => '\"' + s.name.value + '\"').join(', ');\n        context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment \"${spreadName}\" within itself` + (viaPath !== '' ? ` via ${viaPath}.` : '.'), {\n          nodes: cyclePath\n        }));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"],"names":["Object","defineProperty","exports","value","NoFragmentCyclesRule","_GraphQLError","require","context","visitedFrags","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","detectCycleRecursive","fragment","name","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","length","spreadNode","spreadName","cycleIndex","push","undefined","spreadFragment","getFragment","cyclePath","slice","viaPath","map","s","join","reportError","GraphQLError","nodes","pop"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,oBAAR,GAA+BA,oBAA/B;;AAEA,IAAIC,aAAa,GAAGC,OAAO,CAAC,6BAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,oBAAT,CAA8BG,OAA9B,EAAuC;AACrC;AACA;AACA,QAAMC,YAAY,GAAGR,MAAM,CAACS,MAAP,CAAc,IAAd,CAArB,CAHqC,CAGK;;AAE1C,QAAMC,UAAU,GAAG,EAAnB,CALqC,CAKd;;AAEvB,QAAMC,qBAAqB,GAAGX,MAAM,CAACS,MAAP,CAAc,IAAd,CAA9B;AACA,SAAO;AACLG,IAAAA,mBAAmB,EAAE,MAAM,KADtB;;AAGLC,IAAAA,kBAAkB,CAACC,IAAD,EAAO;AACvBC,MAAAA,oBAAoB,CAACD,IAAD,CAApB;AACA,aAAO,KAAP;AACD;;AANI,GAAP,CARqC,CAelC;AACH;AACA;;AAEA,WAASC,oBAAT,CAA8BC,QAA9B,EAAwC;AACtC,QAAIR,YAAY,CAACQ,QAAQ,CAACC,IAAT,CAAcd,KAAf,CAAhB,EAAuC;AACrC;AACD;;AAED,UAAMe,YAAY,GAAGF,QAAQ,CAACC,IAAT,CAAcd,KAAnC;AACAK,IAAAA,YAAY,CAACU,YAAD,CAAZ,GAA6B,IAA7B;AACA,UAAMC,WAAW,GAAGZ,OAAO,CAACa,kBAAR,CAA2BJ,QAAQ,CAACK,YAApC,CAApB;;AAEA,QAAIF,WAAW,CAACG,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B;AACD;;AAEDX,IAAAA,qBAAqB,CAACO,YAAD,CAArB,GAAsCR,UAAU,CAACY,MAAjD;;AAEA,SAAK,MAAMC,UAAX,IAAyBJ,WAAzB,EAAsC;AACpC,YAAMK,UAAU,GAAGD,UAAU,CAACN,IAAX,CAAgBd,KAAnC;AACA,YAAMsB,UAAU,GAAGd,qBAAqB,CAACa,UAAD,CAAxC;AACAd,MAAAA,UAAU,CAACgB,IAAX,CAAgBH,UAAhB;;AAEA,UAAIE,UAAU,KAAKE,SAAnB,EAA8B;AAC5B,cAAMC,cAAc,GAAGrB,OAAO,CAACsB,WAAR,CAAoBL,UAApB,CAAvB;;AAEA,YAAII,cAAJ,EAAoB;AAClBb,UAAAA,oBAAoB,CAACa,cAAD,CAApB;AACD;AACF,OAND,MAMO;AACL,cAAME,SAAS,GAAGpB,UAAU,CAACqB,KAAX,CAAiBN,UAAjB,CAAlB;AACA,cAAMO,OAAO,GAAGF,SAAS,CACtBC,KADa,CACP,CADO,EACJ,CAAC,CADG,EAEbE,GAFa,CAERC,CAAD,IAAO,MAAMA,CAAC,CAACjB,IAAF,CAAOd,KAAb,GAAqB,GAFnB,EAGbgC,IAHa,CAGR,IAHQ,CAAhB;AAIA5B,QAAAA,OAAO,CAAC6B,WAAR,CACE,IAAI/B,aAAa,CAACgC,YAAlB,CACG,2BAA0Bb,UAAW,iBAAtC,IACGQ,OAAO,KAAK,EAAZ,GAAkB,QAAOA,OAAQ,GAAjC,GAAsC,GADzC,CADF,EAGE;AACEM,UAAAA,KAAK,EAAER;AADT,SAHF,CADF;AASD;;AAEDpB,MAAAA,UAAU,CAAC6B,GAAX;AACD;;AAED5B,IAAAA,qBAAqB,CAACO,YAAD,CAArB,GAAsCS,SAAtC;AACD;AACF","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.NoFragmentCyclesRule = NoFragmentCyclesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nfunction NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}