{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _keyValMap = require('../jsutils/keyValMap.js');\n\nvar _parser = require('../language/parser.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _valueFromAST = require('./valueFromAST.js');\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\n\nfunction buildClientSchema(introspection, options) {\n  (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, typeIntrospection => typeIntrospection.name, typeIntrospection => buildType(typeIntrospection)); // Include standard types only if they are used.\n\n  for (const stdType of [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new _definition.GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return (0, _definition.assertObjectType)(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return (0, _definition.assertInterfaceType)(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case _introspection.TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case _introspection.TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case _introspection.TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case _introspection.TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case _introspection.TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case _introspection.TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = (0, _inspect.inspect)(type);\n    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);\n      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection)\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection)\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);\n      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);\n    }\n\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);\n      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);\n    }\n\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, valueIntrospection => valueIntrospection.name, valueIntrospection => ({\n        description: valueIntrospection.description,\n        deprecationReason: valueIntrospection.deprecationReason\n      }))\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);\n      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);\n    }\n\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);\n    }\n\n    return (0, _keyValMap.keyValMap)(typeIntrospection.fields, fieldIntrospection => fieldIntrospection.name, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!(0, _definition.isOutputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);\n      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap.keyValMap)(inputValueIntrospections, inputValue => inputValue.name, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!(0, _definition.isInputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);\n    }\n\n    const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);\n      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);\n      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);\n    }\n\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/buildClientSchema.js"],"names":["Object","defineProperty","exports","value","buildClientSchema","_devAssert","require","_inspect","_isObjectLike","_keyValMap","_parser","_definition","_directives","_introspection","_scalars","_schema","_valueFromAST","introspection","options","isObjectLike","__schema","devAssert","inspect","schemaIntrospection","typeMap","keyValMap","types","typeIntrospection","name","buildType","stdType","specifiedScalarTypes","introspectionTypes","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","GraphQLSchema","description","query","mutation","subscription","values","assumeValid","getType","typeRef","kind","TypeKind","LIST","itemRef","ofType","Error","GraphQLList","NON_NULL","nullableRef","nullableType","GraphQLNonNull","assertNullableType","getNamedType","typeName","type","assertObjectType","getInterfaceType","assertInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","GraphQLScalarType","specifiedByURL","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","GraphQLObjectType","fields","buildFieldDefMap","interfaceIntrospection","GraphQLInterfaceType","unionIntrospection","possibleTypes","unionIntrospectionStr","GraphQLUnionType","enumIntrospection","enumValues","enumIntrospectionStr","GraphQLEnumType","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","GraphQLInputObjectType","buildInputValueDefMap","fieldIntrospection","buildField","isOutputType","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","isInputType","defaultValue","valueFromAST","parseValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","GraphQLDirective","isRepeatable","slice"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _keyValMap = require('../jsutils/keyValMap.js');\n\nvar _parser = require('../language/parser.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _valueFromAST = require('./valueFromAST.js');\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nfunction buildClientSchema(introspection, options) {\n  ((0, _isObjectLike.isObjectLike)(introspection) &&\n    (0, _isObjectLike.isObjectLike)(introspection.__schema)) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${(0,\n      _inspect.inspect)(introspection)}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = (0, _keyValMap.keyValMap)(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [\n    ..._scalars.specifiedScalarTypes,\n    ..._introspection.introspectionTypes,\n  ]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new _definition.GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new _definition.GraphQLNonNull(\n        (0, _definition.assertNullableType)(nullableType),\n      );\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\n        `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`,\n      );\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return (0, _definition.assertObjectType)(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return (0, _definition.assertInterfaceType)(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case _introspection.TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case _introspection.TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case _introspection.TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case _introspection.TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case _introspection.TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case _introspection.TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = (0, _inspect.inspect)(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === _introspection.TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = (0, _inspect.inspect)(\n        implementingIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap.keyValMap)(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = (0, _inspect.inspect)(\n        inputObjectIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${(0, _inspect.inspect)(\n          typeIntrospection,\n        )}.`,\n      );\n    }\n\n    return (0, _keyValMap.keyValMap)(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!(0, _definition.isOutputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap.keyValMap)(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!(0, _definition.isInputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? (0, _valueFromAST.valueFromAST)(\n            (0, _parser.parseValue)(inputValueIntrospection.defaultValue),\n            type,\n          )\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(\n        directiveIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(\n        directiveIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}