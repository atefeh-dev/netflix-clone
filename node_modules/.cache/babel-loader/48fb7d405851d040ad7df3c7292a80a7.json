{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.print = print;\n\nvar _blockString = require('./blockString.js');\n\nvar _printString = require('./printString.js');\n\nvar _visitor = require('./visitor.js');\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\n\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, printDocASTReducer);\n}\n\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' '); // Anonymous queries with no directives or variable definitions can use\n      // the query short form.\n\n      return (prefix === 'query' ? '' : prefix + ' ') + node.selectionSet;\n    }\n\n  },\n  VariableDefinition: {\n    leave: _ref => {\n      let {\n        variable,\n        type,\n        defaultValue,\n        directives\n      } = _ref;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: _ref2 => {\n      let {\n        selections\n      } = _ref2;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave(_ref3) {\n      let {\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      } = _ref3;\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n\n  },\n  Argument: {\n    leave: _ref4 => {\n      let {\n        name,\n        value\n      } = _ref4;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: _ref5 => {\n      let {\n        name,\n        directives\n      } = _ref5;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: _ref6 => {\n      let {\n        typeCondition,\n        directives,\n        selectionSet\n      } = _ref6;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: (_ref7 // Note: fragment variable definitions are experimental and may be changed\n    ) => {\n      let {\n        name,\n        typeCondition,\n        variableDefinitions,\n        directives,\n        selectionSet\n      } = _ref7;\n      return (// or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: _ref8 => {\n      let {\n        value\n      } = _ref8;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: _ref9 => {\n      let {\n        value\n      } = _ref9;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: _ref10 => {\n      let {\n        value,\n        block: isBlockString\n      } = _ref10;\n      return isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value);\n    }\n  },\n  BooleanValue: {\n    leave: _ref11 => {\n      let {\n        value\n      } = _ref11;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: _ref12 => {\n      let {\n        value\n      } = _ref12;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: _ref13 => {\n      let {\n        values\n      } = _ref13;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: _ref14 => {\n      let {\n        fields\n      } = _ref14;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: _ref15 => {\n      let {\n        name,\n        value\n      } = _ref15;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: _ref16 => {\n      let {\n        name,\n        arguments: args\n      } = _ref16;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: _ref17 => {\n      let {\n        name\n      } = _ref17;\n      return name;\n    }\n  },\n  ListType: {\n    leave: _ref18 => {\n      let {\n        type\n      } = _ref18;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: _ref19 => {\n      let {\n        type\n      } = _ref19;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: _ref20 => {\n      let {\n        description,\n        directives,\n        operationTypes\n      } = _ref20;\n      return wrap('', description, '\\n') + join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: _ref21 => {\n      let {\n        operation,\n        type\n      } = _ref21;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: _ref22 => {\n      let {\n        description,\n        name,\n        directives\n      } = _ref22;\n      return wrap('', description, '\\n') + join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: _ref23 => {\n      let {\n        description,\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref23;\n      return wrap('', description, '\\n') + join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: _ref24 => {\n      let {\n        description,\n        name,\n        arguments: args,\n        type,\n        directives\n      } = _ref24;\n      return wrap('', description, '\\n') + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: _ref25 => {\n      let {\n        description,\n        name,\n        type,\n        defaultValue,\n        directives\n      } = _ref25;\n      return wrap('', description, '\\n') + join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: _ref26 => {\n      let {\n        description,\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref26;\n      return wrap('', description, '\\n') + join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: _ref27 => {\n      let {\n        description,\n        name,\n        directives,\n        types\n      } = _ref27;\n      return wrap('', description, '\\n') + join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: _ref28 => {\n      let {\n        description,\n        name,\n        directives,\n        values\n      } = _ref28;\n      return wrap('', description, '\\n') + join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: _ref29 => {\n      let {\n        description,\n        name,\n        directives\n      } = _ref29;\n      return wrap('', description, '\\n') + join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: _ref30 => {\n      let {\n        description,\n        name,\n        directives,\n        fields\n      } = _ref30;\n      return wrap('', description, '\\n') + join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: _ref31 => {\n      let {\n        description,\n        name,\n        arguments: args,\n        repeatable,\n        locations\n      } = _ref31;\n      return wrap('', description, '\\n') + 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: _ref32 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref32;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: _ref33 => {\n      let {\n        name,\n        directives\n      } = _ref33;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: _ref34 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref34;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: _ref35 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref35;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: _ref36 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref36;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: _ref37 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref37;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: _ref38 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref38;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\nfunction join(maybeArray) {\n  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var _maybeArray$filter$jo;\n\n  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(x => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an indented `{ }` block.\n */\n\n\nfunction block(array) {\n  return wrap('{\\n', indent(join(array, '\\n')), '\\n}');\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */\n\n\nfunction wrap(start, maybeString) {\n  let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return maybeString != null && maybeString !== '' ? start + maybeString + end : '';\n}\n\nfunction indent(str) {\n  return wrap('  ', str.replace(/\\n/g, '\\n  '));\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n\n  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/language/printer.js"],"names":["Object","defineProperty","exports","value","print","_blockString","require","_printString","_visitor","ast","visit","printDocASTReducer","MAX_LINE_LENGTH","Name","leave","node","Variable","name","Document","join","definitions","OperationDefinition","varDefs","wrap","variableDefinitions","prefix","operation","directives","selectionSet","VariableDefinition","variable","type","defaultValue","SelectionSet","selections","block","Field","alias","arguments","args","argsLine","length","indent","Argument","FragmentSpread","InlineFragment","typeCondition","FragmentDefinition","IntValue","FloatValue","StringValue","isBlockString","printBlockString","printString","BooleanValue","NullValue","EnumValue","ListValue","values","ObjectValue","fields","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","description","operationTypes","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","interfaces","FieldDefinition","hasMultilineItems","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","types","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","repeatable","locations","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","maybeArray","separator","_maybeArray$filter$jo","filter","x","array","start","maybeString","end","str","replace","_maybeArray$some","some","includes"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.print = print;\n\nvar _blockString = require('./blockString.js');\n\nvar _printString = require('./printString.js');\n\nvar _visitor = require('./visitor.js');\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, printDocASTReducer);\n}\n\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: (node) => node.value,\n  },\n  Variable: {\n    leave: (node) => '$' + node.name,\n  },\n  // Document\n  Document: {\n    leave: (node) => join(node.definitions, '\\n\\n'),\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join(\n        [\n          node.operation,\n          join([node.name, varDefs]),\n          join(node.directives, ' '),\n        ],\n        ' ',\n      ); // Anonymous queries with no directives or variable definitions can use\n      // the query short form.\n\n      return (prefix === 'query' ? '' : prefix + ' ') + node.selectionSet;\n    },\n  },\n  VariableDefinition: {\n    leave: ({ variable, type, defaultValue, directives }) =>\n      variable +\n      ': ' +\n      type +\n      wrap(' = ', defaultValue) +\n      wrap(' ', join(directives, ' ')),\n  },\n  SelectionSet: {\n    leave: ({ selections }) => block(selections),\n  },\n  Field: {\n    leave({ alias, name, arguments: args, directives, selectionSet }) {\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    },\n  },\n  Argument: {\n    leave: ({ name, value }) => name + ': ' + value,\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: ({ name, directives }) =>\n      '...' + name + wrap(' ', join(directives, ' ')),\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) =>\n      join(\n        [\n          '...',\n          wrap('on ', typeCondition),\n          join(directives, ' '),\n          selectionSet,\n        ],\n        ' ',\n      ),\n  },\n  FragmentDefinition: {\n    leave: (\n      { name, typeCondition, variableDefinitions, directives, selectionSet }, // Note: fragment variable definitions are experimental and may be changed\n    ) =>\n      // or removed in the future.\n      `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n      `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n      selectionSet,\n  },\n  // Value\n  IntValue: {\n    leave: ({ value }) => value,\n  },\n  FloatValue: {\n    leave: ({ value }) => value,\n  },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) =>\n      isBlockString\n        ? (0, _blockString.printBlockString)(value)\n        : (0, _printString.printString)(value),\n  },\n  BooleanValue: {\n    leave: ({ value }) => (value ? 'true' : 'false'),\n  },\n  NullValue: {\n    leave: () => 'null',\n  },\n  EnumValue: {\n    leave: ({ value }) => value,\n  },\n  ListValue: {\n    leave: ({ values }) => '[' + join(values, ', ') + ']',\n  },\n  ObjectValue: {\n    leave: ({ fields }) => '{' + join(fields, ', ') + '}',\n  },\n  ObjectField: {\n    leave: ({ name, value }) => name + ': ' + value,\n  },\n  // Directive\n  Directive: {\n    leave: ({ name, arguments: args }) =>\n      '@' + name + wrap('(', join(args, ', '), ')'),\n  },\n  // Type\n  NamedType: {\n    leave: ({ name }) => name,\n  },\n  ListType: {\n    leave: ({ type }) => '[' + type + ']',\n  },\n  NonNullType: {\n    leave: ({ type }) => type + '!',\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: ({ description, directives, operationTypes }) =>\n      wrap('', description, '\\n') +\n      join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type }) => operation + ': ' + type,\n  },\n  ScalarTypeDefinition: {\n    leave: ({ description, name, directives }) =>\n      wrap('', description, '\\n') +\n      join(['scalar', name, join(directives, ' ')], ' '),\n  },\n  ObjectTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(\n        [\n          'type',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  FieldDefinition: {\n    leave: ({ description, name, arguments: args, type, directives }) =>\n      wrap('', description, '\\n') +\n      name +\n      (hasMultilineItems(args)\n        ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n        : wrap('(', join(args, ', '), ')')) +\n      ': ' +\n      type +\n      wrap(' ', join(directives, ' ')),\n  },\n  InputValueDefinition: {\n    leave: ({ description, name, type, defaultValue, directives }) =>\n      wrap('', description, '\\n') +\n      join(\n        [name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')],\n        ' ',\n      ),\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(\n        [\n          'interface',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  UnionTypeDefinition: {\n    leave: ({ description, name, directives, types }) =>\n      wrap('', description, '\\n') +\n      join(\n        ['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))],\n        ' ',\n      ),\n  },\n  EnumTypeDefinition: {\n    leave: ({ description, name, directives, values }) =>\n      wrap('', description, '\\n') +\n      join(['enum', name, join(directives, ' '), block(values)], ' '),\n  },\n  EnumValueDefinition: {\n    leave: ({ description, name, directives }) =>\n      wrap('', description, '\\n') + join([name, join(directives, ' ')], ' '),\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ description, name, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(['input', name, join(directives, ' '), block(fields)], ' '),\n  },\n  DirectiveDefinition: {\n    leave: ({ description, name, arguments: args, repeatable, locations }) =>\n      wrap('', description, '\\n') +\n      'directive @' +\n      name +\n      (hasMultilineItems(args)\n        ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n        : wrap('(', join(args, ', '), ')')) +\n      (repeatable ? ' repeatable' : '') +\n      ' on ' +\n      join(locations, ' | '),\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) =>\n      join(\n        ['extend schema', join(directives, ' '), block(operationTypes)],\n        ' ',\n      ),\n  },\n  ScalarTypeExtension: {\n    leave: ({ name, directives }) =>\n      join(['extend scalar', name, join(directives, ' ')], ' '),\n  },\n  ObjectTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) =>\n      join(\n        [\n          'extend type',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) =>\n      join(\n        [\n          'extend interface',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  UnionTypeExtension: {\n    leave: ({ name, directives, types }) =>\n      join(\n        [\n          'extend union',\n          name,\n          join(directives, ' '),\n          wrap('= ', join(types, ' | ')),\n        ],\n        ' ',\n      ),\n  },\n  EnumTypeExtension: {\n    leave: ({ name, directives, values }) =>\n      join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name, directives, fields }) =>\n      join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n  },\n};\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\nfunction join(maybeArray, separator = '') {\n  var _maybeArray$filter$jo;\n\n  return (_maybeArray$filter$jo =\n    maybeArray === null || maybeArray === void 0\n      ? void 0\n      : maybeArray.filter((x) => x).join(separator)) !== null &&\n    _maybeArray$filter$jo !== void 0\n    ? _maybeArray$filter$jo\n    : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an indented `{ }` block.\n */\n\nfunction block(array) {\n  return wrap('{\\n', indent(join(array, '\\n')), '\\n}');\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */\n\nfunction wrap(start, maybeString, end = '') {\n  return maybeString != null && maybeString !== ''\n    ? start + maybeString + end\n    : '';\n}\n\nfunction indent(str) {\n  return wrap('  ', str.replace(/\\n/g, '\\n  '));\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some;\n\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n  return (_maybeArray$some =\n    maybeArray === null || maybeArray === void 0\n      ? void 0\n      : maybeArray.some((str) => str.includes('\\n'))) !== null &&\n    _maybeArray$some !== void 0\n    ? _maybeArray$some\n    : false;\n}\n"]},"metadata":{},"sourceType":"script"}