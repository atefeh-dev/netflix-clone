{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _astFromValue = require('./astFromValue.js');\n\nvar _sortValueNode = require('./sortValueNode.js');\n\nlet BreakingChangeType;\nexports.BreakingChangeType = BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));\n\nlet DangerousChangeType;\nexports.DangerousChangeType = DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\n\nfunction findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in BreakingChangeType);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in DangerousChangeType);\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [...findTypeChanges(oldSchema, newSchema), ...findDirectiveChanges(oldSchema, newSchema)];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if ((0, _definition.isRequiredArgument)(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  for (const newField of fieldsDiff.added) {\n    if ((0, _definition.isRequiredInputField)(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if ((0, _definition.isRequiredArgument)(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = (0, _astFromValue.astFromValue)(value, type);\n  ast != null || (0, _invariant.invariant)(false);\n  return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = (0, _keyMap.keyMap)(oldArray, _ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  });\n  const newMap = (0, _keyMap.keyMap)(newArray, _ref2 => {\n    let {\n      name\n    } = _ref2;\n    return name;\n  });\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed\n  };\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/findBreakingChanges.js"],"names":["Object","defineProperty","exports","value","DangerousChangeType","BreakingChangeType","findBreakingChanges","findDangerousChanges","_inspect","require","_invariant","_keyMap","_printer","_definition","_scalars","_astFromValue","_sortValueNode","oldSchema","newSchema","findSchemaChanges","filter","change","type","findTypeChanges","findDirectiveChanges","schemaChanges","directivesDiff","diff","getDirectives","oldDirective","removed","push","DIRECTIVE_REMOVED","description","name","newDirective","persisted","argsDiff","args","newArg","added","isRequiredArgument","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","isRepeatable","DIRECTIVE_REPEATABLE_REMOVED","location","locations","includes","DIRECTIVE_LOCATION_REMOVED","typesDiff","values","getTypeMap","oldType","TYPE_REMOVED","isSpecifiedScalarType","newType","isEnumType","findEnumTypeChanges","isUnionType","findUnionTypeChanges","isInputObjectType","findInputObjectTypeChanges","isObjectType","findFieldChanges","findImplementedInterfacesChanges","isInterfaceType","constructor","TYPE_CHANGED_KIND","typeKindName","fieldsDiff","getFields","newField","isRequiredInputField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","String","possibleTypesDiff","getTypes","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","valuesDiff","getValues","newValue","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","interfacesDiff","getInterfaces","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","isChangeSafeForObjectOrInterfaceField","ARG_REMOVED","ARG_CHANGED_KIND","defaultValue","undefined","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","isListType","ofType","isNonNullType","isNamedType","isScalarType","invariant","inspect","ast","astFromValue","print","sortValueNode","oldArray","newArray","oldMap","keyMap","newMap","oldItem","newItem"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _astFromValue = require('./astFromValue.js');\n\nvar _sortValueNode = require('./sortValueNode.js');\n\nlet BreakingChangeType;\nexports.BreakingChangeType = BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(\n  BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}),\n);\n\nlet DangerousChangeType;\nexports.DangerousChangeType = DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(\n  DangerousChangeType ||\n    (exports.DangerousChangeType = DangerousChangeType = {}),\n);\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nfunction findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if ((0, _definition.isRequiredArgument)(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: (0, _scalars.isSpecifiedScalarType)(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (\n      (0, _definition.isEnumType)(oldType) &&\n      (0, _definition.isEnumType)(newType)\n    ) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (\n      (0, _definition.isUnionType)(oldType) &&\n      (0, _definition.isUnionType)(newType)\n    ) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (\n      (0, _definition.isInputObjectType)(oldType) &&\n      (0, _definition.isInputObjectType)(newType)\n    ) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (\n      (0, _definition.isObjectType)(oldType) &&\n      (0, _definition.isObjectType)(newType)\n    ) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (\n      (0, _definition.isInterfaceType)(oldType) &&\n      (0, _definition.isInterfaceType)(newType)\n    ) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if ((0, _definition.isRequiredInputField)(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if ((0, _definition.isRequiredArgument)(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      ((0, _definition.isListType)(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      ((0, _definition.isNonNullType)(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      (0, _definition.isNonNullType)(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    ((0, _definition.isNamedType)(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    ((0, _definition.isNonNullType)(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      (0, _definition.isListType)(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      ((0, _definition.isNonNullType)(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!(0, _definition.isNonNullType)(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected type: ' + (0, _inspect.inspect)(type),\n    );\n}\n\nfunction stringifyValue(value, type) {\n  const ast = (0, _astFromValue.astFromValue)(value, type);\n  ast != null || (0, _invariant.invariant)(false);\n  return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);\n  const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}