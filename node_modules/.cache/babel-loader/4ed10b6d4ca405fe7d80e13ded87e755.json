{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getArgumentValues = getArgumentValues;\nexports.getDirectiveValues = getDirectiveValues;\nexports.getVariableValues = getVariableValues;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printPathArray = require('../jsutils/printPathArray.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _coerceInputValue = require('../utilities/coerceInputValue.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _valueFromAST = require('../utilities/valueFromAST.js');\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(schema, varDefNodes, inputs, error => {\n      if (maxErrors != null && errors.length >= maxErrors) {\n        throw new _GraphQLError.GraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');\n      }\n\n      errors.push(error);\n    });\n\n    if (errors.length === 0) {\n      return {\n        coerced\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);\n\n    if (!(0, _definition.isInputType)(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = (0, _printer.print)(varDefNode.type);\n      onError(new _GraphQLError.GraphQLError(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, {\n        nodes: varDefNode.type\n      }));\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);\n      } else if ((0, _definition.isNonNullType)(varType)) {\n        const varTypeStr = (0, _inspect.inspect)(varType);\n        onError(new _GraphQLError.GraphQLError(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, {\n          nodes: varDefNode\n        }));\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && (0, _definition.isNonNullType)(varType)) {\n      const varTypeStr = (0, _inspect.inspect)(varType);\n      onError(new _GraphQLError.GraphQLError(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, {\n        nodes: varDefNode\n      }));\n      continue;\n    }\n\n    coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error) => {\n      let prefix = `Variable \"$${varName}\" got invalid value ` + (0, _inspect.inspect)(invalidValue);\n\n      if (path.length > 0) {\n        prefix += ` at \"${varName}${(0, _printPathArray.printPathArray)(path)}\"`;\n      }\n\n      onError(new _GraphQLError.GraphQLError(prefix + '; ' + error.message, {\n        nodes: varDefNode,\n        originalError: error.originalError\n      }));\n    });\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];\n  const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, arg => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if ((0, _definition.isNonNullType)(argType)) {\n        throw new _GraphQLError.GraphQLError(`Argument \"${name}\" of required type \"${(0, _inspect.inspect)(argType)}\" ` + 'was not provided.', {\n          nodes: node\n        });\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === _kinds.Kind.NULL;\n\n    if (valueNode.kind === _kinds.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if ((0, _definition.isNonNullType)(argType)) {\n          throw new _GraphQLError.GraphQLError(`Argument \"${name}\" of required type \"${(0, _inspect.inspect)(argType)}\" ` + `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, {\n            nodes: valueNode\n          });\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && (0, _definition.isNonNullType)(argType)) {\n      throw new _GraphQLError.GraphQLError(`Argument \"${name}\" of non-null type \"${(0, _inspect.inspect)(argType)}\" ` + 'must not be null.', {\n        nodes: valueNode\n      });\n    }\n\n    const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new _GraphQLError.GraphQLError(`Argument \"${name}\" has invalid value ${(0, _printer.print)(valueNode)}.`, {\n        nodes: valueNode\n      });\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(directive => directive.name.value === directiveDef.name);\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/execution/values.js"],"names":["Object","defineProperty","exports","value","getArgumentValues","getDirectiveValues","getVariableValues","_inspect","require","_keyMap","_printPathArray","_GraphQLError","_kinds","_printer","_definition","_coerceInputValue","_typeFromAST","_valueFromAST","schema","varDefNodes","inputs","options","errors","maxErrors","coerced","coerceVariableValues","error","length","GraphQLError","push","onError","coercedValues","varDefNode","varName","variable","name","varType","typeFromAST","type","isInputType","varTypeStr","print","nodes","hasOwnProperty","defaultValue","valueFromAST","isNonNullType","inspect","coerceInputValue","path","invalidValue","prefix","printPathArray","message","originalError","def","node","variableValues","_node$arguments","argumentNodes","arguments","argNodeMap","keyMap","arg","argDef","args","argType","argumentNode","undefined","valueNode","isNull","kind","Kind","NULL","VARIABLE","variableName","coercedValue","directiveDef","_node$directives","directiveNode","directives","find","directive","obj","prop","prototype","call"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.getArgumentValues = getArgumentValues;\nexports.getDirectiveValues = getDirectiveValues;\nexports.getVariableValues = getVariableValues;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printPathArray = require('../jsutils/printPathArray.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _coerceInputValue = require('../utilities/coerceInputValue.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _valueFromAST = require('../utilities/valueFromAST.js');\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new _GraphQLError.GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);\n\n    if (!(0, _definition.isInputType)(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = (0, _printer.print)(varDefNode.type);\n      onError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(\n          varDefNode.defaultValue,\n          varType,\n        );\n      } else if ((0, _definition.isNonNullType)(varType)) {\n        const varTypeStr = (0, _inspect.inspect)(varType);\n        onError(\n          new _GraphQLError.GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && (0, _definition.isNonNullType)(varType)) {\n      const varTypeStr = (0, _inspect.inspect)(varType);\n      onError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` +\n          (0, _inspect.inspect)(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${(0, _printPathArray.printPathArray)(\n            path,\n          )}\"`;\n        }\n\n        onError(\n          new _GraphQLError.GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error.originalError,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = (0, _keyMap.keyMap)(\n    argumentNodes,\n    (arg) => arg.name.value,\n  );\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if ((0, _definition.isNonNullType)(argType)) {\n        throw new _GraphQLError.GraphQLError(\n          `Argument \"${name}\" of required type \"${(0, _inspect.inspect)(\n            argType,\n          )}\" ` + 'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === _kinds.Kind.NULL;\n\n    if (valueNode.kind === _kinds.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if ((0, _definition.isNonNullType)(argType)) {\n          throw new _GraphQLError.GraphQLError(\n            `Argument \"${name}\" of required type \"${(0, _inspect.inspect)(\n              argType,\n            )}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && (0, _definition.isNonNullType)(argType)) {\n      throw new _GraphQLError.GraphQLError(\n        `Argument \"${name}\" of non-null type \"${(0, _inspect.inspect)(\n          argType,\n        )}\" ` + 'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = (0, _valueFromAST.valueFromAST)(\n      valueNode,\n      argType,\n      variableValues,\n    );\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new _GraphQLError.GraphQLError(\n        `Argument \"${name}\" has invalid value ${(0, _printer.print)(\n          valueNode,\n        )}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n"]},"metadata":{},"sourceType":"script"}