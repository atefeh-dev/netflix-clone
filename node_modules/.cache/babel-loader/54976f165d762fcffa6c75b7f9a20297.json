{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.KnownDirectivesRule = KnownDirectivesRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _ast = require('../../language/ast.js');\n\nvar _directiveLocation = require('../../language/directiveLocation.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _directives = require('../../type/directives.js');\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\n\n\nfunction KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map(name => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(new _GraphQLError.GraphQLError(`Unknown directive \"@${name}\".`, {\n          nodes: node\n        }));\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(new _GraphQLError.GraphQLError(`Directive \"@${name}\" may not be used on ${candidateLocation}.`, {\n          nodes: node\n        }));\n      }\n    }\n\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || (0, _invariant.invariant)(false);\n\n  switch (appliedTo.kind) {\n    case _kinds.Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case _kinds.Kind.FIELD:\n      return _directiveLocation.DirectiveLocation.FIELD;\n\n    case _kinds.Kind.FRAGMENT_SPREAD:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;\n\n    case _kinds.Kind.INLINE_FRAGMENT:\n      return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;\n\n    case _kinds.Kind.FRAGMENT_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case _kinds.Kind.VARIABLE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;\n\n    case _kinds.Kind.SCHEMA_DEFINITION:\n    case _kinds.Kind.SCHEMA_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCHEMA;\n\n    case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCALAR;\n\n    case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.OBJECT;\n\n    case _kinds.Kind.FIELD_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;\n\n    case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INTERFACE;\n\n    case _kinds.Kind.UNION_TYPE_DEFINITION:\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.UNION;\n\n    case _kinds.Kind.ENUM_TYPE_DEFINITION:\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.ENUM;\n\n    case _kinds.Kind.ENUM_VALUE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.ENUM_VALUE;\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INPUT_OBJECT;\n\n    case _kinds.Kind.INPUT_VALUE_DEFINITION:\n      {\n        const parentNode = ancestors[ancestors.length - 3];\n        'kind' in parentNode || (0, _invariant.invariant)(false);\n        return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;\n      }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || (0, _invariant.invariant)(false, 'Unexpected kind: ' + (0, _inspect.inspect)(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case _ast.OperationTypeNode.QUERY:\n      return _directiveLocation.DirectiveLocation.QUERY;\n\n    case _ast.OperationTypeNode.MUTATION:\n      return _directiveLocation.DirectiveLocation.MUTATION;\n\n    case _ast.OperationTypeNode.SUBSCRIPTION:\n      return _directiveLocation.DirectiveLocation.SUBSCRIPTION;\n  }\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/KnownDirectivesRule.js"],"names":["Object","defineProperty","exports","value","KnownDirectivesRule","_inspect","require","_invariant","_GraphQLError","_ast","_directiveLocation","_kinds","_directives","context","locationsMap","create","schema","getSchema","definedDirectives","getDirectives","specifiedDirectives","directive","name","locations","astDefinitions","getDocument","definitions","def","kind","Kind","DIRECTIVE_DEFINITION","map","Directive","node","_key","_parent","_path","ancestors","reportError","GraphQLError","nodes","candidateLocation","getDirectiveLocationForASTPath","includes","appliedTo","length","invariant","OPERATION_DEFINITION","getDirectiveLocationForOperation","operation","FIELD","DirectiveLocation","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE_DEFINITION","SCHEMA_DEFINITION","SCHEMA_EXTENSION","SCHEMA","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","SCALAR","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","OBJECT","FIELD_DEFINITION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","INTERFACE","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","UNION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","ENUM","ENUM_VALUE_DEFINITION","ENUM_VALUE","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","INPUT_OBJECT","INPUT_VALUE_DEFINITION","parentNode","INPUT_FIELD_DEFINITION","ARGUMENT_DEFINITION","inspect","OperationTypeNode","QUERY","MUTATION","SUBSCRIPTION"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownDirectivesRule = KnownDirectivesRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _ast = require('../../language/ast.js');\n\nvar _directiveLocation = require('../../language/directiveLocation.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _directives = require('../../type/directives.js');\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nfunction KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : _directives.specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || (0, _invariant.invariant)(false);\n\n  switch (appliedTo.kind) {\n    case _kinds.Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case _kinds.Kind.FIELD:\n      return _directiveLocation.DirectiveLocation.FIELD;\n\n    case _kinds.Kind.FRAGMENT_SPREAD:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;\n\n    case _kinds.Kind.INLINE_FRAGMENT:\n      return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;\n\n    case _kinds.Kind.FRAGMENT_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case _kinds.Kind.VARIABLE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;\n\n    case _kinds.Kind.SCHEMA_DEFINITION:\n    case _kinds.Kind.SCHEMA_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCHEMA;\n\n    case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCALAR;\n\n    case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.OBJECT;\n\n    case _kinds.Kind.FIELD_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;\n\n    case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INTERFACE;\n\n    case _kinds.Kind.UNION_TYPE_DEFINITION:\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.UNION;\n\n    case _kinds.Kind.ENUM_TYPE_DEFINITION:\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.ENUM;\n\n    case _kinds.Kind.ENUM_VALUE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.ENUM_VALUE;\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INPUT_OBJECT;\n\n    case _kinds.Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || (0, _invariant.invariant)(false);\n      return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION\n        : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false ||\n        (0, _invariant.invariant)(\n          false,\n          'Unexpected kind: ' + (0, _inspect.inspect)(appliedTo.kind),\n        );\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case _ast.OperationTypeNode.QUERY:\n      return _directiveLocation.DirectiveLocation.QUERY;\n\n    case _ast.OperationTypeNode.MUTATION:\n      return _directiveLocation.DirectiveLocation.MUTATION;\n\n    case _ast.OperationTypeNode.SUBSCRIPTION:\n      return _directiveLocation.DirectiveLocation.SUBSCRIPTION;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}