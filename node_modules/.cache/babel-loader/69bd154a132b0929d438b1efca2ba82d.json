{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\n\n\nfunction UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n\n    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new _GraphQLError.GraphQLError(`Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`, {\n          nodes: fieldDef.name\n        }));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new _GraphQLError.GraphQLError(`Field \"${typeName}.${fieldName}\" can only be defined once.`, {\n          nodes: [fieldNames[fieldName], fieldDef.name]\n        }));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"],"names":["Object","defineProperty","exports","value","UniqueFieldDefinitionNamesRule","_GraphQLError","require","_definition","context","schema","getSchema","existingTypeMap","getTypeMap","create","knownFieldNames","InputObjectTypeDefinition","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeDefinition","InterfaceTypeExtension","ObjectTypeDefinition","ObjectTypeExtension","node","_node$fields","typeName","name","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","reportError","GraphQLError","nodes","type","isObjectType","isInterfaceType","isInputObjectType","getFields"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nfunction UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (\n    (0, _definition.isObjectType)(type) ||\n    (0, _definition.isInterfaceType)(type) ||\n    (0, _definition.isInputObjectType)(type)\n  ) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}