{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.doTypesOverlap = doTypesOverlap;\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\n\nvar _definition = require('../type/definition.js');\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\n\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(type => schema.isSubType(typeB, type));\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/typeComparators.js"],"names":["Object","defineProperty","exports","value","doTypesOverlap","isEqualType","isTypeSubTypeOf","_definition","require","typeA","typeB","isNonNullType","ofType","isListType","schema","maybeSubType","superType","isAbstractType","isInterfaceType","isObjectType","isSubType","getPossibleTypes","some","type"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.doTypesOverlap = doTypesOverlap;\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\n\nvar _definition = require('../type/definition.js');\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n  if (\n    (0, _definition.isNonNullType)(typeA) &&\n    (0, _definition.isNonNullType)(typeB)\n  ) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n  if (\n    (0, _definition.isListType)(typeA) &&\n    (0, _definition.isListType)(typeB)\n  ) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n  return (\n    (0, _definition.isAbstractType)(superType) &&\n    ((0, _definition.isInterfaceType)(maybeSubType) ||\n      (0, _definition.isObjectType)(maybeSubType)) &&\n    schema.isSubType(superType, maybeSubType)\n  );\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema\n        .getPossibleTypes(typeA)\n        .some((type) => schema.isSubType(typeB, type));\n    } // Determine if the latter type is a possible concrete type of the former.\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}