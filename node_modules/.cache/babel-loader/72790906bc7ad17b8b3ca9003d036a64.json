{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.valueFromAST = valueFromAST;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Unknown       |\n * | NullValue            | null          |\n *\n */\n\n\nfunction valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === _kinds.Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    const variableValue = variables[variableName];\n\n    if (variableValue === null && (0, _definition.isNonNullType)(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if ((0, _definition.isNonNullType)(type)) {\n    if (valueNode.kind === _kinds.Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === _kinds.Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n\n    if (valueNode.kind === _kinds.Kind.LIST) {\n      const coercedValues = [];\n\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if ((0, _definition.isNonNullType)(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    const coercedObj = Object.create(null);\n    const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, field => field.name.value);\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n\n\n  false || (0, _invariant.invariant)(false, 'Unexpected input type: ' + (0, _inspect.inspect)(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/valueFromAST.js"],"names":["Object","defineProperty","exports","value","valueFromAST","_inspect","require","_invariant","_keyMap","_kinds","_definition","valueNode","type","variables","kind","Kind","VARIABLE","variableName","name","undefined","variableValue","isNonNullType","NULL","ofType","isListType","itemType","LIST","coercedValues","itemNode","values","isMissingVariable","push","itemValue","coercedValue","isInputObjectType","OBJECT","coercedObj","create","fieldNodes","keyMap","fields","field","getFields","fieldNode","defaultValue","fieldValue","isLeafType","result","parseLiteral","_error","invariant","inspect"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.valueFromAST = valueFromAST;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Unknown       |\n * | NullValue            | null          |\n *\n */\nfunction valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === _kinds.Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    const variableValue = variables[variableName];\n\n    if (variableValue === null && (0, _definition.isNonNullType)(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n    return variableValue;\n  }\n\n  if ((0, _definition.isNonNullType)(type)) {\n    if (valueNode.kind === _kinds.Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === _kinds.Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n\n    if (valueNode.kind === _kinds.Kind.LIST) {\n      const coercedValues = [];\n\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if ((0, _definition.isNonNullType)(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    const coercedObj = Object.create(null);\n    const fieldNodes = (0, _keyMap.keyMap)(\n      valueNode.fields,\n      (field) => field.name.value,\n    );\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected input type: ' + (0, _inspect.inspect)(type),\n    );\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return (\n    valueNode.kind === _kinds.Kind.VARIABLE &&\n    (variables == null || variables[valueNode.name.value] === undefined)\n  );\n}\n"]},"metadata":{},"sourceType":"script"}