{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.Lexer = void 0;\nexports.isPunctuatorTokenKind = isPunctuatorTokenKind;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _blockString = require('./blockString.js');\n\nvar _characterClasses = require('./characterClasses.js');\n\nvar _tokenKind = require('./tokenKind.js');\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\n\nclass Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n\n  advance() {\n    this.lastToken = this.token;\n    const token = this.token = this.lookahead();\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== _tokenKind.TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === _tokenKind.TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n\n}\n/**\n * @internal\n */\n\n\nexports.Lexer = Lexer;\n\nfunction isPunctuatorTokenKind(kind) {\n  return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\n\nfunction isUnicodeScalarValue(code) {\n  return code >= 0x0000 && code <= 0xd7ff || code >= 0xe000 && code <= 0x10ffff;\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\n\nfunction isSupplementaryCodePoint(body, location) {\n  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return _tokenKind.TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new _ast.Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, _tokenKind.TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, _tokenKind.TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (body.charCodeAt(position + 1) === 0x002e && body.charCodeAt(position + 2) === 0x002e) {\n          return createToken(lexer, _tokenKind.TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, _tokenKind.TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, _tokenKind.TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, _tokenKind.TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, _tokenKind.TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n\n    if ((0, _characterClasses.isDigit)(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n\n    if ((0, _characterClasses.isNameStart)(code)) {\n      return readName(lexer, position);\n    }\n\n    throw (0, _syntaxError.syntaxError)(lexer.source, position, code === 0x0027 ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);\n  }\n\n  return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if ((0, _characterClasses.isDigit)(code)) {\n      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 0x002e || (0, _characterClasses.isNameStart)(code)) {\n    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);\n  }\n\n  return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!(0, _characterClasses.isDigit)(firstCode)) {\n    throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, _tokenKind.TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape = body.charCodeAt(position + 1) === 0x0075 // u\n      ? body.charCodeAt(position + 2) === 0x007b // {\n      ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size\n      };\n    } // Append this hex digit to the code point.\n\n\n    point = point << 4 | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: \"${body.slice(position, position + size)}\".`);\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (body.charCodeAt(position + 6) === 0x005c && body.charCodeAt(position + 7) === 0x0075) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12\n        };\n      }\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`);\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n  ? code - 0x0030 : code >= 0x0041 && code <= 0x0046 // A-F\n  ? code - 0x0037 : code >= 0x0061 && code <= 0x0066 // a-f\n  ? code - 0x0057 : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2\n      };\n  }\n\n  throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character escape sequence: \"${body.slice(position, position + 2)}\".`);\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (code === 0x0022 && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position + 3, // Return a string of the lines joined with U+000A.\n      (0, _blockString.dedentBlockStringLines)(blockLines).join('\\n'));\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n\n    if (code === 0x005c && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022 && body.charCodeAt(position + 3) === 0x0022) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if ((0, _characterClasses.isNameContinue)(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(lexer, _tokenKind.TokenKind.NAME, start, position, body.slice(start, position));\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/language/lexer.js"],"names":["Object","defineProperty","exports","value","Lexer","isPunctuatorTokenKind","_syntaxError","require","_ast","_blockString","_characterClasses","_tokenKind","constructor","source","startOfFileToken","Token","TokenKind","SOF","lastToken","token","line","lineStart","Symbol","toStringTag","advance","lookahead","kind","EOF","next","nextToken","readNextToken","end","prev","COMMENT","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","isUnicodeScalarValue","code","isSupplementaryCodePoint","body","location","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","undefined","char","String","fromCodePoint","toString","toUpperCase","padStart","createToken","start","col","bodyLength","length","position","readComment","readBlockString","readString","isDigit","readNumber","isNameStart","readName","syntaxError","slice","firstCode","isFloat","readDigits","FLOAT","INT","chunkStart","STRING","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","push","BLOCK_STRING","dedentBlockStringLines","join","isNameContinue","NAME"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.Lexer = void 0;\nexports.isPunctuatorTokenKind = isPunctuatorTokenKind;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _blockString = require('./blockString.js');\n\nvar _characterClasses = require('./characterClasses.js');\n\nvar _tokenKind = require('./tokenKind.js');\n\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nclass Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new _ast.Token(\n      _tokenKind.TokenKind.SOF,\n      0,\n      0,\n      0,\n      0,\n    );\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== _tokenKind.TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === _tokenKind.TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexports.Lexer = Lexer;\n\nfunction isPunctuatorTokenKind(kind) {\n  return (\n    kind === _tokenKind.TokenKind.BANG ||\n    kind === _tokenKind.TokenKind.DOLLAR ||\n    kind === _tokenKind.TokenKind.AMP ||\n    kind === _tokenKind.TokenKind.PAREN_L ||\n    kind === _tokenKind.TokenKind.PAREN_R ||\n    kind === _tokenKind.TokenKind.SPREAD ||\n    kind === _tokenKind.TokenKind.COLON ||\n    kind === _tokenKind.TokenKind.EQUALS ||\n    kind === _tokenKind.TokenKind.AT ||\n    kind === _tokenKind.TokenKind.BRACKET_L ||\n    kind === _tokenKind.TokenKind.BRACKET_R ||\n    kind === _tokenKind.TokenKind.BRACE_L ||\n    kind === _tokenKind.TokenKind.PIPE ||\n    kind === _tokenKind.TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return _tokenKind.TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new _ast.Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BANG,\n          position,\n          position + 1,\n        );\n\n      case 0x0024:\n        // $\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.DOLLAR,\n          position,\n          position + 1,\n        );\n\n      case 0x0026:\n        // &\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.AMP,\n          position,\n          position + 1,\n        );\n\n      case 0x0028:\n        // (\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.PAREN_L,\n          position,\n          position + 1,\n        );\n\n      case 0x0029:\n        // )\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.PAREN_R,\n          position,\n          position + 1,\n        );\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(\n            lexer,\n            _tokenKind.TokenKind.SPREAD,\n            position,\n            position + 3,\n          );\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.COLON,\n          position,\n          position + 1,\n        );\n\n      case 0x003d:\n        // =\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.EQUALS,\n          position,\n          position + 1,\n        );\n\n      case 0x0040:\n        // @\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.AT,\n          position,\n          position + 1,\n        );\n\n      case 0x005b:\n        // [\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACKET_L,\n          position,\n          position + 1,\n        );\n\n      case 0x005d:\n        // ]\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACKET_R,\n          position,\n          position + 1,\n        );\n\n      case 0x007b:\n        // {\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACE_L,\n          position,\n          position + 1,\n        );\n\n      case 0x007c:\n        // |\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.PIPE,\n          position,\n          position + 1,\n        );\n\n      case 0x007d:\n        // }\n        return createToken(\n          lexer,\n          _tokenKind.TokenKind.BRACE_R,\n          position,\n          position + 1,\n        );\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if ((0, _characterClasses.isDigit)(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if ((0, _characterClasses.isNameStart)(code)) {\n      return readName(lexer, position);\n    }\n\n    throw (0, _syntaxError.syntaxError)(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    _tokenKind.TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if ((0, _characterClasses.isDigit)(code)) {\n      throw (0, _syntaxError.syntaxError)(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || (0, _characterClasses.isNameStart)(code)) {\n    throw (0, _syntaxError.syntaxError)(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!(0, _characterClasses.isDigit)(firstCode)) {\n    throw (0, _syntaxError.syntaxError)(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(\n        lexer,\n        _tokenKind.TokenKind.STRING,\n        start,\n        position + 1,\n        value,\n      );\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    'Unterminated string.',\n  );\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        _tokenKind.TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        (0, _blockString.dedentBlockStringLines)(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(\n    lexer.source,\n    position,\n    'Unterminated string.',\n  );\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if ((0, _characterClasses.isNameContinue)(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    _tokenKind.TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n"]},"metadata":{},"sourceType":"script"}