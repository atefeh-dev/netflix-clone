{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateOperations = separateOperations;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\n\nfunction separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n\n      default: // ignore non-executable definitions\n\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(node => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))\n    };\n  }\n\n  return separatedDocumentASTs;\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  (0, _visitor.visit)(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n\n  });\n  return dependencies;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/separateOperations.js"],"names":["Object","defineProperty","exports","value","separateOperations","_kinds","require","_visitor","documentAST","operations","depGraph","create","definitionNode","definitions","kind","Kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","collectDependencies","selectionSet","separatedDocumentASTs","operation","dependencies","Set","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","toName","visit","FragmentSpread"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.separateOperations = separateOperations;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nfunction separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === _kinds.Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  (0, _visitor.visit)(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n"]},"metadata":{},"sourceType":"script"}