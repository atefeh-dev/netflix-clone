{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.assertValidSchema = assertValidSchema;\nexports.validateSchema = validateSchema;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _typeComparators = require('../utilities/typeComparators.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\nvar _schema = require('./schema.js');\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\n\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  (0, _schema.assertSchema)(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\n\nfunction assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(new _GraphQLError.GraphQLError(message, {\n      nodes: _nodes\n    }));\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  schemaNode => {\n    var _schemaNode$operation;\n\n    return (\n      /* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(operationNode => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!(0, _directives.isDirective)(directive)) {\n      context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);\n      }\n\n      if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!(0, _definition.isNamedType)(type)) {\n      context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!(0, _introspection.isIntrospectionType)(type)) {\n      validateName(context, type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isUnionType)(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if ((0, _definition.isEnumType)(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [type.astNode, ...type.extensionASTNodes]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!(0, _definition.isOutputType)(field.type)) {\n      var _field$astNode;\n\n      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!(0, _definition.isInterfaceType)(iface)) {\n      context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, ` + `it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${(0, _inspect.inspect)(typeField.type)}.`, [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find(arg => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${(0, _inspect.inspect)(typeArg.type)}.`, [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    } // Assert additional arguments must not be required.\n\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find(arg => arg.name === argName);\n\n      if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {\n        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [...getAllImplementsInterfaceNodes(iface, transitive), ...getAllImplementsInterfaceNodes(type, iface)]);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!(0, _definition.isObjectType)(memberType)) {\n      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  } // Ensure the arguments are valid\n\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!(0, _definition.isInputType)(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map(fieldObj => fieldObj.astNode));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = type;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(typeNode => {\n    var _typeNode$interfaces;\n\n    return (\n      /* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(ifaceNode => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = union;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(unionNode => {\n    var _unionNode$types;\n\n    return (\n      /* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(typeNode => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(node => node.name.value === _directives.GraphQLDeprecatedDirective.name);\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/type/validate.js"],"names":["Object","defineProperty","exports","value","assertValidSchema","validateSchema","_inspect","require","_GraphQLError","_ast","_typeComparators","_definition","_directives","_introspection","_schema","schema","assertSchema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","length","Error","map","error","message","join","constructor","_errors","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","GraphQLError","queryType","getQueryType","astNode","isObjectType","_getOperationTypeNode","inspect","getOperationTypeNode","OperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","directive","getDirectives","isDirective","validateName","arg","args","isInputType","name","isRequiredArgument","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","values","isNamedType","isIntrospectionType","validateFields","validateInterfaces","isInterfaceType","isUnionType","validateUnionMembers","isEnumType","validateEnumValues","isInputObjectType","validateInputFields","fields","getFields","field","isOutputType","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","iface","getInterfaces","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","isTypeSubTypeOf","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","isEqualType","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","isRequiredInputField","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","isNonNullType","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives","GraphQLDeprecatedDirective"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.assertValidSchema = assertValidSchema;\nexports.validateSchema = validateSchema;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _typeComparators = require('../utilities/typeComparators.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\nvar _schema = require('./schema.js');\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  (0, _schema.assertSchema)(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nfunction assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new _GraphQLError.GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${(0,\n      _inspect.inspect)(queryType)}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${(0, _inspect.inspect)(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${(0, _inspect.inspect)(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!(0, _directives.isDirective)(directive)) {\n      context.reportError(\n        `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${(0, _inspect.inspect)(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (\n        (0, _definition.isRequiredArgument)(arg) &&\n        arg.deprecationReason != null\n      ) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!(0, _definition.isNamedType)(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!(0, _introspection.isIntrospectionType)(type)) {\n      validateName(context, type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isUnionType)(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if ((0, _definition.isEnumType)(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!(0, _definition.isOutputType)(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${(0, _inspect.inspect)(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${(0, _inspect.inspect)(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (\n        (0, _definition.isRequiredArgument)(arg) &&\n        arg.deprecationReason != null\n      ) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!(0, _definition.isInterfaceType)(iface)) {\n      context.reportError(\n        `Type ${(0, _inspect.inspect)(\n          type,\n        )} must only implement Interface types, ` +\n          `it cannot implement ${(0, _inspect.inspect)(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (\n      !(0, _typeComparators.isTypeSubTypeOf)(\n        context.schema,\n        typeField.type,\n        ifaceField.type,\n      )\n    ) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${(0, _inspect.inspect)(ifaceField.type)} but ${\n            type.name\n          }.${fieldName} ` +\n          `is type ${(0, _inspect.inspect)(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${(0, _inspect.inspect)(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!(0, _definition.isObjectType)(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${(0, _inspect.inspect)(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!(0, _definition.isInputType)(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${(0, _inspect.inspect)(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (\n      (0, _definition.isRequiredInputField)(field) &&\n      field.deprecationReason != null\n    ) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (\n        (0, _definition.isNonNullType)(field.type) &&\n        (0, _definition.isInputObjectType)(field.type.ofType)\n      ) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) =>\n          node.name.value === _directives.GraphQLDeprecatedDirective.name,\n      );\n}\n"]},"metadata":{},"sourceType":"script"}