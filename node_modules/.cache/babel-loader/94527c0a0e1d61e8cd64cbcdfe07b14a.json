{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _keyMap = require('../../jsutils/keyMap.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\n\n\nfunction ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = (0, _definition.getNullableType)(context.getParentInputType());\n\n      if (!(0, _definition.isListType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, field => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          const typeStr = (0, _inspect.inspect)(fieldDef.type);\n          context.reportError(new _GraphQLError.GraphQLError(`Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`, {\n            nodes: node\n          }));\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = (0, _definition.getNamedType)(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new _GraphQLError.GraphQLError(`Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` + (0, _didYouMean.didYouMean)(suggestions), {\n          nodes: node\n        }));\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${(0, _inspect.inspect)(type)}\", found ${(0, _printer.print)(node)}.`, {\n          nodes: node\n        }));\n      }\n    },\n\n    EnumValue: node => isValidValueNode(context, node),\n    IntValue: node => isValidValueNode(context, node),\n    FloatValue: node => isValidValueNode(context, node),\n    StringValue: node => isValidValueNode(context, node),\n    BooleanValue: node => isValidValueNode(context, node)\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = (0, _definition.getNamedType)(locationType);\n\n  if (!(0, _definition.isLeafType)(type)) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n    context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${typeStr}\", found ${(0, _printer.print)(node)}.`, {\n      nodes: node\n    }));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n\n  try {\n    const parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = (0, _inspect.inspect)(locationType);\n      context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${typeStr}\", found ${(0, _printer.print)(node)}.`, {\n        nodes: node\n      }));\n    }\n  } catch (error) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n\n    if (error instanceof _GraphQLError.GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${typeStr}\", found ${(0, _printer.print)(node)}; ` + error.message, {\n        nodes: node,\n        originalError: error\n      }));\n    }\n  }\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"],"names":["Object","defineProperty","exports","value","ValuesOfCorrectTypeRule","_didYouMean","require","_inspect","_keyMap","_suggestionList","_GraphQLError","_printer","_definition","context","ListValue","node","type","getNullableType","getParentInputType","isListType","isValidValueNode","ObjectValue","getNamedType","getInputType","isInputObjectType","fieldNodeMap","keyMap","fields","field","name","fieldDef","values","getFields","fieldNode","isRequiredInputField","typeStr","inspect","reportError","GraphQLError","nodes","ObjectField","parentType","fieldType","suggestions","suggestionList","keys","didYouMean","NullValue","isNonNullType","print","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","locationType","isLeafType","parseResult","parseLiteral","undefined","error","message","originalError"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _keyMap = require('../../jsutils/keyMap.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nfunction ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = (0, _definition.getNullableType)(\n        context.getParentInputType(),\n      );\n\n      if (!(0, _definition.isListType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = (0, _keyMap.keyMap)(\n        node.fields,\n        (field) => field.name.value,\n      );\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          const typeStr = (0, _inspect.inspect)(fieldDef.type);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = (0, _definition.getNamedType)(\n        context.getParentInputType(),\n      );\n      const fieldType = context.getInputType();\n\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        const suggestions = (0, _suggestionList.suggestionList)(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              (0, _didYouMean.didYouMean)(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Expected value of type \"${(0, _inspect.inspect)(\n              type,\n            )}\", found ${(0, _printer.print)(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = (0, _definition.getNamedType)(locationType);\n\n  if (!(0, _definition.isLeafType)(type)) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n    context.reportError(\n      new _GraphQLError.GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n          node,\n        )}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = (0, _inspect.inspect)(locationType);\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n            node,\n          )}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n\n    if (error instanceof _GraphQLError.GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n            node,\n          )}; ` + error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}