{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\n\n\nfunction FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);\n\n        if (type && !(0, _definition.isCompositeType)(type)) {\n          const typeStr = (0, _printer.print)(typeCondition);\n          context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type \"${typeStr}\".`, {\n            nodes: typeCondition\n          }));\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);\n\n      if (type && !(0, _definition.isCompositeType)(type)) {\n        const typeStr = (0, _printer.print)(node.typeCondition);\n        context.reportError(new _GraphQLError.GraphQLError(`Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`, {\n          nodes: node.typeCondition\n        }));\n      }\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"],"names":["Object","defineProperty","exports","value","FragmentsOnCompositeTypesRule","_GraphQLError","require","_printer","_definition","_typeFromAST","context","InlineFragment","node","typeCondition","type","typeFromAST","getSchema","isCompositeType","typeStr","print","reportError","GraphQLError","nodes","FragmentDefinition","name"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,6BAAR,GAAwCA,6BAAxC;;AAEA,IAAIC,aAAa,GAAGC,OAAO,CAAC,6BAAD,CAA3B;;AAEA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,2BAAD,CAAtB;;AAEA,IAAIE,WAAW,GAAGF,OAAO,CAAC,0BAAD,CAAzB;;AAEA,IAAIG,YAAY,GAAGH,OAAO,CAAC,gCAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,6BAAT,CAAuCM,OAAvC,EAAgD;AAC9C,SAAO;AACLC,IAAAA,cAAc,CAACC,IAAD,EAAO;AACnB,YAAMC,aAAa,GAAGD,IAAI,CAACC,aAA3B;;AAEA,UAAIA,aAAJ,EAAmB;AACjB,cAAMC,IAAI,GAAG,CAAC,GAAGL,YAAY,CAACM,WAAjB,EACXL,OAAO,CAACM,SAAR,EADW,EAEXH,aAFW,CAAb;;AAKA,YAAIC,IAAI,IAAI,CAAC,CAAC,GAAGN,WAAW,CAACS,eAAhB,EAAiCH,IAAjC,CAAb,EAAqD;AACnD,gBAAMI,OAAO,GAAG,CAAC,GAAGX,QAAQ,CAACY,KAAb,EAAoBN,aAApB,CAAhB;AACAH,UAAAA,OAAO,CAACU,WAAR,CACE,IAAIf,aAAa,CAACgB,YAAlB,CACG,oDAAmDH,OAAQ,IAD9D,EAEE;AACEI,YAAAA,KAAK,EAAET;AADT,WAFF,CADF;AAQD;AACF;AACF,KAtBI;;AAwBLU,IAAAA,kBAAkB,CAACX,IAAD,EAAO;AACvB,YAAME,IAAI,GAAG,CAAC,GAAGL,YAAY,CAACM,WAAjB,EACXL,OAAO,CAACM,SAAR,EADW,EAEXJ,IAAI,CAACC,aAFM,CAAb;;AAKA,UAAIC,IAAI,IAAI,CAAC,CAAC,GAAGN,WAAW,CAACS,eAAhB,EAAiCH,IAAjC,CAAb,EAAqD;AACnD,cAAMI,OAAO,GAAG,CAAC,GAAGX,QAAQ,CAACY,KAAb,EAAoBP,IAAI,CAACC,aAAzB,CAAhB;AACAH,QAAAA,OAAO,CAACU,WAAR,CACE,IAAIf,aAAa,CAACgB,YAAlB,CACG,aAAYT,IAAI,CAACY,IAAL,CAAUrB,KAAM,6CAA4Ce,OAAQ,IADnF,EAEE;AACEI,UAAAA,KAAK,EAAEV,IAAI,CAACC;AADd,SAFF,CADF;AAQD;AACF;;AAzCI,GAAP;AA2CD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nfunction FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = (0, _typeFromAST.typeFromAST)(\n          context.getSchema(),\n          typeCondition,\n        );\n\n        if (type && !(0, _definition.isCompositeType)(type)) {\n          const typeStr = (0, _printer.print)(typeCondition);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = (0, _typeFromAST.typeFromAST)(\n        context.getSchema(),\n        node.typeCondition,\n      );\n\n      if (type && !(0, _definition.isCompositeType)(type)) {\n        const typeStr = (0, _printer.print)(node.typeCondition);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}