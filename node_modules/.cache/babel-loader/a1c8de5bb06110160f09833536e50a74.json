{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.extendSchema = extendSchema;\nexports.extendSchemaImpl = extendSchemaImpl;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _mapValue = require('../jsutils/mapValue.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _predicates = require('../language/predicates.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _validate = require('../validation/validate.js');\n\nvar _values = require('../execution/values.js');\n\nvar _valueFromAST = require('./valueFromAST.js');\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n\n\nfunction extendSchema(schema, documentAST, options) {\n  (0, _schema.assertSchema)(schema);\n  documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\n\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid; // Collect the type definitions and extensions found in the document.\n\n\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      typeDefs.push(def);\n    } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions)\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [...schemaConfig.directives.map(replaceDirective), ...directiveDefs.map(buildDirective)],\n    extensions: Object.create(null),\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    }\n\n    if ((0, _definition.isNonNullType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new _directives.GraphQLDirective({ ...config,\n      args: (0, _mapValue.mapValue)(config.args, extendArg)\n    });\n  }\n\n  function extendNamedType(type) {\n    if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if ((0, _definition.isScalarType)(type)) {\n      return extendScalarType(type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n\n    if ((0, _definition.isEnumType)(type)) {\n      return extendEnumType(type);\n    }\n\n    if ((0, _definition.isInputObjectType)(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n\n    false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new _definition.GraphQLInputObjectType({ ...config,\n      fields: () => ({ ...(0, _mapValue.mapValue)(config.fields, field => ({ ...field,\n          type: replaceType(field.type)\n        })),\n        ...buildInputFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new _definition.GraphQLEnumType({ ...config,\n      values: { ...config.values,\n        ...buildEnumValueMap(extensions)\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;\n    }\n\n    return new _definition.GraphQLScalarType({ ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new _definition.GraphQLObjectType({ ...config,\n      interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],\n      fields: () => ({ ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new _definition.GraphQLInterfaceType({ ...config,\n      interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],\n      fields: () => ({ ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new _definition.GraphQLUnionType({ ...config,\n      types: () => [...type.getTypes().map(replaceNamedType), ...buildUnionTypes(extensions)],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendField(field) {\n    return { ...field,\n      type: replaceType(field.type),\n      args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg,\n      type: replaceType(arg.type)\n    };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n      const operationTypesNodes =\n      /* c8 ignore next */\n      (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === _kinds.Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return new _definition.GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new _directives.GraphQLDirective({\n      name: node.name.value,\n      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(_ref => {\n        let {\n          value\n        } = _ref;\n        return value;\n      }),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n      const nodeFields =\n      /* c8 ignore next */\n      (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n    /* c8 ignore next */\n    args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description; // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n\n\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,\n        defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n      const fieldsNodes =\n      /* c8 ignore next */\n      (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2; // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n\n\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,\n          defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n      const valuesNodes =\n      /* c8 ignore next */\n      (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    node => {\n      var _node$interfaces$map, _node$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []\n      );\n    });\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    node => {\n      var _node$types$map, _node$types;\n\n      return (\n        /* c8 ignore next */\n        (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []\n      );\n    });\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLObjectType({\n            name,\n            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _astNode$description2;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLInterfaceType({\n            name,\n            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _astNode$description3;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLEnumType({\n            name,\n            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,\n            values: buildEnumValueMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n        {\n          var _astNode$description4;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLUnionType({\n            name,\n            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,\n            types: () => buildUnionTypes(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _astNode$description5;\n\n          return new _definition.GraphQLScalarType({\n            name,\n            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,\n            specifiedByURL: getSpecifiedByURL(astNode),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description6;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLInputObjectType({\n            name,\n            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,\n            fields: () => buildInputFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n    }\n  }\n}\n\nconst stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], type => type.name);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/extendSchema.js"],"names":["Object","defineProperty","exports","value","extendSchema","extendSchemaImpl","_devAssert","require","_inspect","_invariant","_keyMap","_mapValue","_kinds","_predicates","_definition","_directives","_introspection","_scalars","_schema","_validate","_values","_valueFromAST","schema","documentAST","options","assertSchema","kind","Kind","DOCUMENT","devAssert","assumeValid","assumeValidSDL","assertValidSDLExtension","schemaConfig","toConfig","extendedConfig","GraphQLSchema","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","typeDefs","typeExtensionsMap","create","directiveDefs","schemaDef","schemaExtensions","def","definitions","SCHEMA_DEFINITION","SCHEMA_EXTENSION","push","isTypeDefinitionNode","isTypeExtensionNode","extendedTypeName","name","existingTypeExtensions","concat","DIRECTIVE_DEFINITION","keys","length","typeMap","existingType","types","extendNamedType","typeNode","_stdTypeMap$name","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","values","directives","map","replaceDirective","buildDirective","extensions","astNode","extensionASTNodes","replaceType","type","isListType","GraphQLList","ofType","isNonNullType","GraphQLNonNull","directive","config","GraphQLDirective","args","mapValue","extendArg","isIntrospectionType","isSpecifiedScalarType","isScalarType","extendScalarType","isObjectType","extendObjectType","isInterfaceType","extendInterfaceType","isUnionType","extendUnionType","isEnumType","extendEnumType","isInputObjectType","extendInputObjectType","invariant","inspect","_typeExtensionsMap$co","GraphQLInputObjectType","fields","field","buildInputFieldMap","_typeExtensionsMap$ty","GraphQLEnumType","buildEnumValueMap","_typeExtensionsMap$co2","specifiedByURL","extensionNode","_getSpecifiedByURL","getSpecifiedByURL","GraphQLScalarType","_typeExtensionsMap$co3","GraphQLObjectType","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","_typeExtensionsMap$co4","GraphQLInterfaceType","_typeExtensionsMap$co5","GraphQLUnionType","getTypes","buildUnionTypes","arg","nodes","opTypes","node","_node$operationTypes","operationTypesNodes","operationType","operation","getNamedType","_stdTypeMap$name2","undefined","Error","getWrappedType","LIST_TYPE","NON_NULL_TYPE","_node$description","locations","isRepeatable","repeatable","buildArgumentMap","arguments","fieldConfigMap","_node$fields","nodeFields","_field$description","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_arg$description","defaultValue","valueFromAST","inputFieldMap","_node$fields2","fieldsNodes","_field$description2","enumValueMap","_node$values","valuesNodes","_value$description","flatMap","_node$interfaces$map","_node$interfaces","_node$types$map","_node$types","_typeExtensionsMap$na","OBJECT_TYPE_DEFINITION","_astNode$description","allNodes","INTERFACE_TYPE_DEFINITION","_astNode$description2","ENUM_TYPE_DEFINITION","_astNode$description3","UNION_TYPE_DEFINITION","_astNode$description4","SCALAR_TYPE_DEFINITION","_astNode$description5","INPUT_OBJECT_TYPE_DEFINITION","_astNode$description6","keyMap","specifiedScalarTypes","introspectionTypes","deprecated","getDirectiveValues","GraphQLDeprecatedDirective","reason","specifiedBy","GraphQLSpecifiedByDirective","url"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.extendSchema = extendSchema;\nexports.extendSchemaImpl = extendSchemaImpl;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _mapValue = require('../jsutils/mapValue.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _predicates = require('../language/predicates.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _validate = require('../validation/validate.js');\n\nvar _values = require('../execution/values.js');\n\nvar _valueFromAST = require('./valueFromAST.js');\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nfunction extendSchema(schema, documentAST, options) {\n  (0, _schema.assertSchema)(schema);\n  (documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT) ||\n    (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new _schema.GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      typeDefs.push(def);\n    } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    }\n\n    if ((0, _definition.isNonNullType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new _directives.GraphQLDirective({\n      ...config,\n      args: (0, _mapValue.mapValue)(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (\n      (0, _introspection.isIntrospectionType)(type) ||\n      (0, _scalars.isSpecifiedScalarType)(type)\n    ) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if ((0, _definition.isScalarType)(type)) {\n      return extendScalarType(type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n\n    if ((0, _definition.isEnumType)(type)) {\n      return extendEnumType(type);\n    }\n\n    if ((0, _definition.isInputObjectType)(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false ||\n      (0, _invariant.invariant)(\n        false,\n        'Unexpected type: ' + (0, _inspect.inspect)(type),\n      );\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new _definition.GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new _definition.GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new _definition.GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new _definition.GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new _definition.GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new _definition.GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && (0, _mapValue.mapValue)(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === _kinds.Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return new _definition.GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new _directives.GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n      /* c8 ignore next */\n      args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: (0, _valueFromAST.valueFromAST)(\n            field.defaultValue,\n            type,\n          ),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (\n          /* c8 ignore next */\n          (_node$interfaces$map =\n            (_node$interfaces = node.interfaces) === null ||\n            _node$interfaces === void 0\n              ? void 0\n              : _node$interfaces.map(getNamedType)) !== null &&\n            _node$interfaces$map !== void 0\n            ? _node$interfaces$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (\n          /* c8 ignore next */\n          (_node$types$map =\n            (_node$types = node.types) === null || _node$types === void 0\n              ? void 0\n              : _node$types.map(getNamedType)) !== null &&\n            _node$types$map !== void 0\n            ? _node$types$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new _definition.GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    }\n  }\n}\n\nconst stdTypeMap = (0, _keyMap.keyMap)(\n  [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = (0, _values.getDirectiveValues)(\n    _directives.GraphQLDeprecatedDirective,\n    node,\n  ); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = (0, _values.getDirectiveValues)(\n    _directives.GraphQLSpecifiedByDirective,\n    node,\n  ); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n"]},"metadata":{},"sourceType":"script"}