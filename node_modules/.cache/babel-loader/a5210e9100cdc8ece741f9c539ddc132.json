{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.collectFields = collectFields;\nexports.collectSubfields = collectSubfields;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _values = require('./values.js');\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\n\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  const fields = new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\n\nfunction collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n\n          break;\n        }\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/execution/collectFields.js"],"names":["Object","defineProperty","exports","value","collectFields","collectSubfields","_kinds","require","_definition","_directives","_typeFromAST","_values","schema","fragments","variableValues","runtimeType","selectionSet","fields","Map","collectFieldsImpl","Set","returnType","fieldNodes","subFieldNodes","visitedFragmentNames","node","selection","selections","kind","Kind","FIELD","shouldIncludeNode","name","getFieldEntryKey","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","has","add","fragment","skip","getDirectiveValues","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","type","typeConditionNode","typeCondition","conditionalType","typeFromAST","isAbstractType","isSubType","alias"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.collectFields = collectFields;\nexports.collectSubfields = collectSubfields;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _values = require('./values.js');\n\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\nfunction collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nfunction collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case _kinds.Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case _kinds.Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, _values.getDirectiveValues)(\n    _directives.GraphQLSkipDirective,\n    node,\n    variableValues,\n  );\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = (0, _values.getDirectiveValues)(\n    _directives.GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = (0, _typeFromAST.typeFromAST)(\n    schema,\n    typeConditionNode,\n  );\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n"]},"metadata":{},"sourceType":"script"}