{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = void 0;\nexports.argsToArgsConfig = argsToArgsConfig;\nexports.assertAbstractType = assertAbstractType;\nexports.assertCompositeType = assertCompositeType;\nexports.assertEnumType = assertEnumType;\nexports.assertInputObjectType = assertInputObjectType;\nexports.assertInputType = assertInputType;\nexports.assertInterfaceType = assertInterfaceType;\nexports.assertLeafType = assertLeafType;\nexports.assertListType = assertListType;\nexports.assertNamedType = assertNamedType;\nexports.assertNonNullType = assertNonNullType;\nexports.assertNullableType = assertNullableType;\nexports.assertObjectType = assertObjectType;\nexports.assertOutputType = assertOutputType;\nexports.assertScalarType = assertScalarType;\nexports.assertType = assertType;\nexports.assertUnionType = assertUnionType;\nexports.assertWrappingType = assertWrappingType;\nexports.defineArguments = defineArguments;\nexports.getNamedType = getNamedType;\nexports.getNullableType = getNullableType;\nexports.isAbstractType = isAbstractType;\nexports.isCompositeType = isCompositeType;\nexports.isEnumType = isEnumType;\nexports.isInputObjectType = isInputObjectType;\nexports.isInputType = isInputType;\nexports.isInterfaceType = isInterfaceType;\nexports.isLeafType = isLeafType;\nexports.isListType = isListType;\nexports.isNamedType = isNamedType;\nexports.isNonNullType = isNonNullType;\nexports.isNullableType = isNullableType;\nexports.isObjectType = isObjectType;\nexports.isOutputType = isOutputType;\nexports.isRequiredArgument = isRequiredArgument;\nexports.isRequiredInputField = isRequiredInputField;\nexports.isScalarType = isScalarType;\nexports.isType = isType;\nexports.isUnionType = isUnionType;\nexports.isWrappingType = isWrappingType;\nexports.resolveObjMapThunk = resolveObjMapThunk;\nexports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _didYouMean = require('../jsutils/didYouMean.js');\n\nvar _identityFunc = require('../jsutils/identityFunc.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _instanceOf = require('../jsutils/instanceOf.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _keyValMap = require('../jsutils/keyValMap.js');\n\nvar _mapValue = require('../jsutils/mapValue.js');\n\nvar _suggestionList = require('../jsutils/suggestionList.js');\n\nvar _toObjMap = require('../jsutils/toObjMap.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _valueFromASTUntyped = require('../utilities/valueFromASTUntyped.js');\n\nvar _assertName = require('./assertName.js');\n\nfunction isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\n\nfunction assertType(type) {\n  if (!isType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`);\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n\nfunction isScalarType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);\n}\n\nfunction assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`);\n  }\n\n  return type;\n}\n\nfunction isObjectType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);\n}\n\nfunction assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`);\n  }\n\n  return type;\n}\n\nfunction isInterfaceType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);\n}\n\nfunction assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`);\n  }\n\n  return type;\n}\n\nfunction isUnionType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);\n}\n\nfunction assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`);\n  }\n\n  return type;\n}\n\nfunction isEnumType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);\n}\n\nfunction assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`);\n  }\n\n  return type;\n}\n\nfunction isInputObjectType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);\n}\n\nfunction assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Input Object type.`);\n  }\n\n  return type;\n}\n\nfunction isListType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLList);\n}\n\nfunction assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`);\n  }\n\n  return type;\n}\n\nfunction isNonNullType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);\n}\n\nfunction assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\n\nfunction isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\n\nfunction assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\n\nfunction isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\n\nfunction assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\n\nfunction isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\n\nfunction assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nfunction isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\n\nfunction assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nfunction isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\n\nfunction assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`);\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\n\n\nclass GraphQLList {\n  constructor(ofType) {\n    isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString() {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\n\nexports.GraphQLList = GraphQLList;\n\nclass GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString() {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n/**\n * These types wrap and modify other types\n */\n\n\nexports.GraphQLNonNull = GraphQLNonNull;\n\nfunction isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\n\nfunction assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`);\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\n\nfunction isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\n\nfunction assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`);\n  }\n\n  return type;\n}\n\nfunction getNullableType(type) {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\n\nfunction isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\n\nfunction assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`);\n  }\n\n  return type;\n}\n\nfunction getNamedType(type) {\n  if (type) {\n    let unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\n\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function returns `null` or does not return a value\n * (i.e. it returns `undefined`) then an error will be raised and a `null`\n * value will be returned in the response. It is always better to validate\n *\n * Example:\n *\n * ```ts\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   serialize(value) {\n *     if (!Number.isFinite(value)) {\n *       throw new Error(\n *         `Scalar \"Odd\" cannot represent \"${value}\" since it is not a finite number.`,\n *       );\n *     }\n *\n *     if (value % 2 === 0) {\n *       throw new Error(`Scalar \"Odd\" cannot represent \"${value}\" since it is even.`);\n *     }\n *     return value;\n *   }\n * });\n * ```\n */\n\n\nclass GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;\n\n    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    config.specifiedByURL == null || typeof config.specifiedByURL === 'string' || (0, _devAssert.devAssert)(false, `${this.name} must provide \"specifiedByURL\" as a string, ` + `but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`);\n    config.serialize == null || typeof config.serialize === 'function' || (0, _devAssert.devAssert)(false, `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`);\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || (0, _devAssert.devAssert)(false, `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`);\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nexports.GraphQLScalarType = GraphQLScalarType;\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\n\nclass GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];\n\n    this._fields = () => defineFieldMap(config);\n\n    this._interfaces = () => defineInterfaces(config);\n\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || (0, _devAssert.devAssert)(false, `${this.name} must provide \"isTypeOf\" as a function, ` + `but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nexports.GraphQLObjectType = GraphQLObjectType;\n\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n\n  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);\n  Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field config must be an object.`);\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);\n    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);\n    return {\n      name: (0, _assertName.assertName)(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nfunction defineArguments(config) {\n  return Object.entries(config).map(_ref => {\n    let [argName, argConfig] = _ref;\n    return {\n      name: (0, _assertName.assertName)(argName),\n      description: argConfig.description,\n      type: argConfig.type,\n      defaultValue: argConfig.defaultValue,\n      deprecationReason: argConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),\n      astNode: argConfig.astNode\n    };\n  });\n}\n\nfunction isPlainObj(obj) {\n  return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return (0, _mapValue.mapValue)(fields, field => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  }));\n}\n/**\n * @internal\n */\n\n\nfunction argsToArgsConfig(args) {\n  return (0, _keyValMap.keyValMap)(args, arg => arg.name, arg => ({\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    deprecationReason: arg.deprecationReason,\n    extensions: arg.extensions,\n    astNode: arg.astNode\n  }));\n}\n\nfunction isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\n\n\nclass GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    config.resolveType == null || typeof config.resolveType === 'function' || (0, _devAssert.devAssert)(false, `${this.name} must provide \"resolveType\" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nexports.GraphQLInterfaceType = GraphQLInterfaceType;\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\n\nclass GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];\n    this._types = defineTypes.bind(undefined, config);\n    config.resolveType == null || typeof config.resolveType === 'function' || (0, _devAssert.devAssert)(false, `${this.name} must provide \"resolveType\" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nexports.GraphQLUnionType = GraphQLUnionType;\n\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nclass GraphQLEnumType {\n  /* <T> */\n  constructor(config) {\n    var _config$extensionASTN5;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(enumValue => [enumValue.value, enumValue]));\n    this._nameLookup = (0, _keyMap.keyMap)(this._values, value => value.name);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues() {\n    return this._values;\n  }\n\n  getValue(name) {\n    return this._nameLookup[name];\n  }\n\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new _GraphQLError.GraphQLError(`Enum \"${this.name}\" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);\n    }\n\n    return enumValue.name;\n  }\n\n  parseValue(inputValue)\n  /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      const valueStr = (0, _inspect.inspect)(inputValue);\n      throw new _GraphQLError.GraphQLError(`Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));\n    }\n\n    const enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new _GraphQLError.GraphQLError(`Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, inputValue));\n    }\n\n    return enumValue.value;\n  }\n\n  parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== _kinds.Kind.ENUM) {\n      const valueStr = (0, _printer.print)(valueNode);\n      throw new _GraphQLError.GraphQLError(`Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {\n        nodes: valueNode\n      });\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      const valueStr = (0, _printer.print)(valueNode);\n      throw new _GraphQLError.GraphQLError(`Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, valueStr), {\n        nodes: valueNode\n      });\n    }\n\n    return enumValue.value;\n  }\n\n  toConfig() {\n    const values = (0, _keyValMap.keyValMap)(this.getValues(), value => value.name, value => ({\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nexports.GraphQLEnumType = GraphQLEnumType;\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map(value => value.name);\n  const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);\n  return (0, _didYouMean.didYouMean)('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);\n  return Object.entries(valueMap).map(_ref2 => {\n    let [valueName, valueConfig] = _ref2;\n    isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a \"value\" key ` + `representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);\n    return {\n      name: (0, _assertName.assertEnumValueName)(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\n\n\nclass GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];\n    this._fields = defineInputFieldMap.bind(undefined, config);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  toConfig() {\n    const fields = (0, _mapValue.mapValue)(this.getFields(), field => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nexports.GraphQLInputObjectType = GraphQLInputObjectType;\n\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {\n    !('resolve' in fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);\n    return {\n      name: (0, _assertName.assertName)(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nfunction isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/type/definition.js"],"names":["Object","defineProperty","exports","value","GraphQLUnionType","GraphQLScalarType","GraphQLObjectType","GraphQLNonNull","GraphQLList","GraphQLInterfaceType","GraphQLInputObjectType","GraphQLEnumType","argsToArgsConfig","assertAbstractType","assertCompositeType","assertEnumType","assertInputObjectType","assertInputType","assertInterfaceType","assertLeafType","assertListType","assertNamedType","assertNonNullType","assertNullableType","assertObjectType","assertOutputType","assertScalarType","assertType","assertUnionType","assertWrappingType","defineArguments","getNamedType","getNullableType","isAbstractType","isCompositeType","isEnumType","isInputObjectType","isInputType","isInterfaceType","isLeafType","isListType","isNamedType","isNonNullType","isNullableType","isObjectType","isOutputType","isRequiredArgument","isRequiredInputField","isScalarType","isType","isUnionType","isWrappingType","resolveObjMapThunk","resolveReadonlyArrayThunk","_devAssert","require","_didYouMean","_identityFunc","_inspect","_instanceOf","_isObjectLike","_keyMap","_keyValMap","_mapValue","_suggestionList","_toObjMap","_GraphQLError","_kinds","_printer","_valueFromASTUntyped","_assertName","type","Error","inspect","instanceOf","ofType","constructor","devAssert","Symbol","toStringTag","toString","String","toJSON","unwrappedType","thunk","config","_config$parseValue","_config$serialize","_config$parseLiteral","_config$extensionASTN","parseValue","identityFunc","name","assertName","description","specifiedByURL","serialize","parseLiteral","node","variables","valueFromASTUntyped","extensions","toObjMap","astNode","extensionASTNodes","toConfig","_config$extensionASTN2","isTypeOf","_fields","defineFieldMap","_interfaces","defineInterfaces","getFields","getInterfaces","interfaces","fields","fieldsToFieldsConfig","_config$interfaces","Array","isArray","fieldMap","isPlainObj","mapValue","fieldConfig","fieldName","_fieldConfig$args","resolve","argsConfig","args","subscribe","deprecationReason","entries","map","argName","argConfig","defaultValue","obj","isObjectLike","field","keyValMap","arg","undefined","_config$extensionASTN3","resolveType","bind","_config$extensionASTN4","_types","defineTypes","getTypes","types","_config$extensionASTN5","_values","defineEnumValues","values","_valueLookup","Map","enumValue","_nameLookup","keyMap","getValues","getValue","outputValue","get","GraphQLError","inputValue","valueStr","didYouMeanEnumValue","valueNode","_variables","kind","Kind","ENUM","print","nodes","enumType","unknownValueStr","allNames","suggestedValues","suggestionList","didYouMean","typeName","valueMap","valueName","valueConfig","assertEnumValueName","_config$extensionASTN6","defineInputFieldMap"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,gBAAR,GACEF,OAAO,CAACG,iBAAR,GACAH,OAAO,CAACI,iBAAR,GACAJ,OAAO,CAACK,cAAR,GACAL,OAAO,CAACM,WAAR,GACAN,OAAO,CAACO,oBAAR,GACAP,OAAO,CAACQ,sBAAR,GACAR,OAAO,CAACS,eAAR,GACE,KAAK,CART;AASAT,OAAO,CAACU,gBAAR,GAA2BA,gBAA3B;AACAV,OAAO,CAACW,kBAAR,GAA6BA,kBAA7B;AACAX,OAAO,CAACY,mBAAR,GAA8BA,mBAA9B;AACAZ,OAAO,CAACa,cAAR,GAAyBA,cAAzB;AACAb,OAAO,CAACc,qBAAR,GAAgCA,qBAAhC;AACAd,OAAO,CAACe,eAAR,GAA0BA,eAA1B;AACAf,OAAO,CAACgB,mBAAR,GAA8BA,mBAA9B;AACAhB,OAAO,CAACiB,cAAR,GAAyBA,cAAzB;AACAjB,OAAO,CAACkB,cAAR,GAAyBA,cAAzB;AACAlB,OAAO,CAACmB,eAAR,GAA0BA,eAA1B;AACAnB,OAAO,CAACoB,iBAAR,GAA4BA,iBAA5B;AACApB,OAAO,CAACqB,kBAAR,GAA6BA,kBAA7B;AACArB,OAAO,CAACsB,gBAAR,GAA2BA,gBAA3B;AACAtB,OAAO,CAACuB,gBAAR,GAA2BA,gBAA3B;AACAvB,OAAO,CAACwB,gBAAR,GAA2BA,gBAA3B;AACAxB,OAAO,CAACyB,UAAR,GAAqBA,UAArB;AACAzB,OAAO,CAAC0B,eAAR,GAA0BA,eAA1B;AACA1B,OAAO,CAAC2B,kBAAR,GAA6BA,kBAA7B;AACA3B,OAAO,CAAC4B,eAAR,GAA0BA,eAA1B;AACA5B,OAAO,CAAC6B,YAAR,GAAuBA,YAAvB;AACA7B,OAAO,CAAC8B,eAAR,GAA0BA,eAA1B;AACA9B,OAAO,CAAC+B,cAAR,GAAyBA,cAAzB;AACA/B,OAAO,CAACgC,eAAR,GAA0BA,eAA1B;AACAhC,OAAO,CAACiC,UAAR,GAAqBA,UAArB;AACAjC,OAAO,CAACkC,iBAAR,GAA4BA,iBAA5B;AACAlC,OAAO,CAACmC,WAAR,GAAsBA,WAAtB;AACAnC,OAAO,CAACoC,eAAR,GAA0BA,eAA1B;AACApC,OAAO,CAACqC,UAAR,GAAqBA,UAArB;AACArC,OAAO,CAACsC,UAAR,GAAqBA,UAArB;AACAtC,OAAO,CAACuC,WAAR,GAAsBA,WAAtB;AACAvC,OAAO,CAACwC,aAAR,GAAwBA,aAAxB;AACAxC,OAAO,CAACyC,cAAR,GAAyBA,cAAzB;AACAzC,OAAO,CAAC0C,YAAR,GAAuBA,YAAvB;AACA1C,OAAO,CAAC2C,YAAR,GAAuBA,YAAvB;AACA3C,OAAO,CAAC4C,kBAAR,GAA6BA,kBAA7B;AACA5C,OAAO,CAAC6C,oBAAR,GAA+BA,oBAA/B;AACA7C,OAAO,CAAC8C,YAAR,GAAuBA,YAAvB;AACA9C,OAAO,CAAC+C,MAAR,GAAiBA,MAAjB;AACA/C,OAAO,CAACgD,WAAR,GAAsBA,WAAtB;AACAhD,OAAO,CAACiD,cAAR,GAAyBA,cAAzB;AACAjD,OAAO,CAACkD,kBAAR,GAA6BA,kBAA7B;AACAlD,OAAO,CAACmD,yBAAR,GAAoCA,yBAApC;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,yBAAD,CAAxB;;AAEA,IAAIC,WAAW,GAAGD,OAAO,CAAC,0BAAD,CAAzB;;AAEA,IAAIE,aAAa,GAAGF,OAAO,CAAC,4BAAD,CAA3B;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,uBAAD,CAAtB;;AAEA,IAAII,WAAW,GAAGJ,OAAO,CAAC,0BAAD,CAAzB;;AAEA,IAAIK,aAAa,GAAGL,OAAO,CAAC,4BAAD,CAA3B;;AAEA,IAAIM,OAAO,GAAGN,OAAO,CAAC,sBAAD,CAArB;;AAEA,IAAIO,UAAU,GAAGP,OAAO,CAAC,yBAAD,CAAxB;;AAEA,IAAIQ,SAAS,GAAGR,OAAO,CAAC,wBAAD,CAAvB;;AAEA,IAAIS,eAAe,GAAGT,OAAO,CAAC,8BAAD,CAA7B;;AAEA,IAAIU,SAAS,GAAGV,OAAO,CAAC,wBAAD,CAAvB;;AAEA,IAAIW,aAAa,GAAGX,OAAO,CAAC,0BAAD,CAA3B;;AAEA,IAAIY,MAAM,GAAGZ,OAAO,CAAC,sBAAD,CAApB;;AAEA,IAAIa,QAAQ,GAAGb,OAAO,CAAC,wBAAD,CAAtB;;AAEA,IAAIc,oBAAoB,GAAGd,OAAO,CAAC,qCAAD,CAAlC;;AAEA,IAAIe,WAAW,GAAGf,OAAO,CAAC,iBAAD,CAAzB;;AAEA,SAASN,MAAT,CAAgBsB,IAAhB,EAAsB;AACpB,SACEvB,YAAY,CAACuB,IAAD,CAAZ,IACA3B,YAAY,CAAC2B,IAAD,CADZ,IAEAjC,eAAe,CAACiC,IAAD,CAFf,IAGArB,WAAW,CAACqB,IAAD,CAHX,IAIApC,UAAU,CAACoC,IAAD,CAJV,IAKAnC,iBAAiB,CAACmC,IAAD,CALjB,IAMA/B,UAAU,CAAC+B,IAAD,CANV,IAOA7B,aAAa,CAAC6B,IAAD,CARf;AAUD;;AAED,SAAS5C,UAAT,CAAoB4C,IAApB,EAA0B;AACxB,MAAI,CAACtB,MAAM,CAACsB,IAAD,CAAX,EAAmB;AACjB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,wBADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAASvB,YAAT,CAAsBuB,IAAtB,EAA4B;AAC1B,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkClE,iBAAlC,CAAP;AACD;;AAED,SAASqB,gBAAT,CAA0B6C,IAA1B,EAAgC;AAC9B,MAAI,CAACvB,YAAY,CAACuB,IAAD,CAAjB,EAAyB;AACvB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,+BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAAS3B,YAAT,CAAsB2B,IAAtB,EAA4B;AAC1B,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkCjE,iBAAlC,CAAP;AACD;;AAED,SAASkB,gBAAT,CAA0B+C,IAA1B,EAAgC;AAC9B,MAAI,CAAC3B,YAAY,CAAC2B,IAAD,CAAjB,EAAyB;AACvB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,+BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAASjC,eAAT,CAAyBiC,IAAzB,EAA+B;AAC7B,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkC9D,oBAAlC,CAAP;AACD;;AAED,SAASS,mBAAT,CAA6BqD,IAA7B,EAAmC;AACjC,MAAI,CAACjC,eAAe,CAACiC,IAAD,CAApB,EAA4B;AAC1B,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,kCADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAASrB,WAAT,CAAqBqB,IAArB,EAA2B;AACzB,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkCnE,gBAAlC,CAAP;AACD;;AAED,SAASwB,eAAT,CAAyB2C,IAAzB,EAA+B;AAC7B,MAAI,CAACrB,WAAW,CAACqB,IAAD,CAAhB,EAAwB;AACtB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,8BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAASpC,UAAT,CAAoBoC,IAApB,EAA0B;AACxB,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkC5D,eAAlC,CAAP;AACD;;AAED,SAASI,cAAT,CAAwBwD,IAAxB,EAA8B;AAC5B,MAAI,CAACpC,UAAU,CAACoC,IAAD,CAAf,EAAuB;AACrB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,6BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAASnC,iBAAT,CAA2BmC,IAA3B,EAAiC;AAC/B,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkC7D,sBAAlC,CAAP;AACD;;AAED,SAASM,qBAAT,CAA+BuD,IAA/B,EAAqC;AACnC,MAAI,CAACnC,iBAAiB,CAACmC,IAAD,CAAtB,EAA8B;AAC5B,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EACVF,IADU,CAEV,qCAHE,CAAN;AAKD;;AAED,SAAOA,IAAP;AACD;;AAED,SAAS/B,UAAT,CAAoB+B,IAApB,EAA0B;AACxB,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkC/D,WAAlC,CAAP;AACD;;AAED,SAASY,cAAT,CAAwBmD,IAAxB,EAA8B;AAC5B,MAAI,CAAC/B,UAAU,CAAC+B,IAAD,CAAf,EAAuB;AACrB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,6BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAAS7B,aAAT,CAAuB6B,IAAvB,EAA6B;AAC3B,SAAO,CAAC,GAAGZ,WAAW,CAACe,UAAhB,EAA4BH,IAA5B,EAAkChE,cAAlC,CAAP;AACD;;AAED,SAASe,iBAAT,CAA2BiD,IAA3B,EAAiC;AAC/B,MAAI,CAAC7B,aAAa,CAAC6B,IAAD,CAAlB,EAA0B;AACxB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,iCADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAASlC,WAAT,CAAqBkC,IAArB,EAA2B;AACzB,SACEvB,YAAY,CAACuB,IAAD,CAAZ,IACApC,UAAU,CAACoC,IAAD,CADV,IAEAnC,iBAAiB,CAACmC,IAAD,CAFjB,IAGCpB,cAAc,CAACoB,IAAD,CAAd,IAAwBlC,WAAW,CAACkC,IAAI,CAACI,MAAN,CAJtC;AAMD;;AAED,SAAS1D,eAAT,CAAyBsD,IAAzB,EAA+B;AAC7B,MAAI,CAAClC,WAAW,CAACkC,IAAD,CAAhB,EAAwB;AACtB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,8BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAAS1B,YAAT,CAAsB0B,IAAtB,EAA4B;AAC1B,SACEvB,YAAY,CAACuB,IAAD,CAAZ,IACA3B,YAAY,CAAC2B,IAAD,CADZ,IAEAjC,eAAe,CAACiC,IAAD,CAFf,IAGArB,WAAW,CAACqB,IAAD,CAHX,IAIApC,UAAU,CAACoC,IAAD,CAJV,IAKCpB,cAAc,CAACoB,IAAD,CAAd,IAAwB1B,YAAY,CAAC0B,IAAI,CAACI,MAAN,CANvC;AAQD;;AAED,SAASlD,gBAAT,CAA0B8C,IAA1B,EAAgC;AAC9B,MAAI,CAAC1B,YAAY,CAAC0B,IAAD,CAAjB,EAAyB;AACvB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,+BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAAShC,UAAT,CAAoBgC,IAApB,EAA0B;AACxB,SAAOvB,YAAY,CAACuB,IAAD,CAAZ,IAAsBpC,UAAU,CAACoC,IAAD,CAAvC;AACD;;AAED,SAASpD,cAAT,CAAwBoD,IAAxB,EAA8B;AAC5B,MAAI,CAAChC,UAAU,CAACgC,IAAD,CAAf,EAAuB;AACrB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,6BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAASrC,eAAT,CAAyBqC,IAAzB,EAA+B;AAC7B,SAAO3B,YAAY,CAAC2B,IAAD,CAAZ,IAAsBjC,eAAe,CAACiC,IAAD,CAArC,IAA+CrB,WAAW,CAACqB,IAAD,CAAjE;AACD;;AAED,SAASzD,mBAAT,CAA6ByD,IAA7B,EAAmC;AACjC,MAAI,CAACrC,eAAe,CAACqC,IAAD,CAApB,EAA4B;AAC1B,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,kCADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAAStC,cAAT,CAAwBsC,IAAxB,EAA8B;AAC5B,SAAOjC,eAAe,CAACiC,IAAD,CAAf,IAAyBrB,WAAW,CAACqB,IAAD,CAA3C;AACD;;AAED,SAAS1D,kBAAT,CAA4B0D,IAA5B,EAAkC;AAChC,MAAI,CAACtC,cAAc,CAACsC,IAAD,CAAnB,EAA2B;AACzB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,iCADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAM/D,WAAN,CAAkB;AAChBoE,EAAAA,WAAW,CAACD,MAAD,EAAS;AAClB1B,IAAAA,MAAM,CAAC0B,MAAD,CAAN,IACE,CAAC,GAAGrB,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,YAAW,CAAC,GAAGnB,QAAQ,CAACe,OAAb,EAAsBE,MAAtB,CAA8B,wBAF5C,CADF;AAKA,SAAKA,MAAL,GAAcA,MAAd;AACD;;AAEsB,OAAlBG,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,aAAP;AACD;;AAEDC,EAAAA,QAAQ,GAAG;AACT,WAAO,MAAMC,MAAM,CAAC,KAAKN,MAAN,CAAZ,GAA4B,GAAnC;AACD;;AAEDO,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AApBe;AAsBlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA9E,OAAO,CAACM,WAAR,GAAsBA,WAAtB;;AAEA,MAAMD,cAAN,CAAqB;AACnBqE,EAAAA,WAAW,CAACD,MAAD,EAAS;AAClBhC,IAAAA,cAAc,CAACgC,MAAD,CAAd,IACE,CAAC,GAAGrB,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,YAAW,CAAC,GAAGnB,QAAQ,CAACe,OAAb,EACVE,MADU,CAEV,iCAJJ,CADF;AAOA,SAAKA,MAAL,GAAcA,MAAd;AACD;;AAEsB,OAAlBG,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,gBAAP;AACD;;AAEDC,EAAAA,QAAQ,GAAG;AACT,WAAOC,MAAM,CAAC,KAAKN,MAAN,CAAN,GAAsB,GAA7B;AACD;;AAEDO,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AAtBkB;AAwBrB;AACA;AACA;;;AAEA9E,OAAO,CAACK,cAAR,GAAyBA,cAAzB;;AAEA,SAAS4C,cAAT,CAAwBoB,IAAxB,EAA8B;AAC5B,SAAO/B,UAAU,CAAC+B,IAAD,CAAV,IAAoB7B,aAAa,CAAC6B,IAAD,CAAxC;AACD;;AAED,SAAS1C,kBAAT,CAA4B0C,IAA5B,EAAkC;AAChC,MAAI,CAACpB,cAAc,CAACoB,IAAD,CAAnB,EAA2B;AACzB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,iCADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;AACD;AACA;AACA;;;AAEA,SAAS5B,cAAT,CAAwB4B,IAAxB,EAA8B;AAC5B,SAAOtB,MAAM,CAACsB,IAAD,CAAN,IAAgB,CAAC7B,aAAa,CAAC6B,IAAD,CAArC;AACD;;AAED,SAAShD,kBAAT,CAA4BgD,IAA5B,EAAkC;AAChC,MAAI,CAAC5B,cAAc,CAAC4B,IAAD,CAAnB,EAA2B;AACzB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,iCADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAASvC,eAAT,CAAyBuC,IAAzB,EAA+B;AAC7B,MAAIA,IAAJ,EAAU;AACR,WAAO7B,aAAa,CAAC6B,IAAD,CAAb,GAAsBA,IAAI,CAACI,MAA3B,GAAoCJ,IAA3C;AACD;AACF;AACD;AACA;AACA;;;AAEA,SAAS9B,WAAT,CAAqB8B,IAArB,EAA2B;AACzB,SACEvB,YAAY,CAACuB,IAAD,CAAZ,IACA3B,YAAY,CAAC2B,IAAD,CADZ,IAEAjC,eAAe,CAACiC,IAAD,CAFf,IAGArB,WAAW,CAACqB,IAAD,CAHX,IAIApC,UAAU,CAACoC,IAAD,CAJV,IAKAnC,iBAAiB,CAACmC,IAAD,CANnB;AAQD;;AAED,SAASlD,eAAT,CAAyBkD,IAAzB,EAA+B;AAC7B,MAAI,CAAC9B,WAAW,CAAC8B,IAAD,CAAhB,EAAwB;AACtB,UAAM,IAAIC,KAAJ,CACH,YAAW,CAAC,GAAGd,QAAQ,CAACe,OAAb,EAAsBF,IAAtB,CAA4B,8BADpC,CAAN;AAGD;;AAED,SAAOA,IAAP;AACD;;AAED,SAASxC,YAAT,CAAsBwC,IAAtB,EAA4B;AAC1B,MAAIA,IAAJ,EAAU;AACR,QAAIY,aAAa,GAAGZ,IAApB;;AAEA,WAAOpB,cAAc,CAACgC,aAAD,CAArB,EAAsC;AACpCA,MAAAA,aAAa,GAAGA,aAAa,CAACR,MAA9B;AACD;;AAED,WAAOQ,aAAP;AACD;AACF;AACD;AACA;AACA;AACA;;;AAEA,SAAS9B,yBAAT,CAAmC+B,KAAnC,EAA0C;AACxC,SAAO,OAAOA,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,EAAnC,GAAwCA,KAA/C;AACD;;AAED,SAAShC,kBAAT,CAA4BgC,KAA5B,EAAmC;AACjC,SAAO,OAAOA,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,EAAnC,GAAwCA,KAA/C;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM/E,iBAAN,CAAwB;AACtBuE,EAAAA,WAAW,CAACS,MAAD,EAAS;AAClB,QAAIC,kBAAJ,EACEC,iBADF,EAEEC,oBAFF,EAGEC,qBAHF;;AAKA,UAAMC,UAAU,GACd,CAACJ,kBAAkB,GAAGD,MAAM,CAACK,UAA7B,MAA6C,IAA7C,IACAJ,kBAAkB,KAAK,KAAK,CAD5B,GAEIA,kBAFJ,GAGI7B,aAAa,CAACkC,YAJpB;AAKA,SAAKC,IAAL,GAAY,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BR,MAAM,CAACO,IAAnC,CAAZ;AACA,SAAKE,WAAL,GAAmBT,MAAM,CAACS,WAA1B;AACA,SAAKC,cAAL,GAAsBV,MAAM,CAACU,cAA7B;AACA,SAAKC,SAAL,GACE,CAACT,iBAAiB,GAAGF,MAAM,CAACW,SAA5B,MAA2C,IAA3C,IACAT,iBAAiB,KAAK,KAAK,CAD3B,GAEIA,iBAFJ,GAGI9B,aAAa,CAACkC,YAJpB;AAKA,SAAKD,UAAL,GAAkBA,UAAlB;AACA,SAAKO,YAAL,GACE,CAACT,oBAAoB,GAAGH,MAAM,CAACY,YAA/B,MAAiD,IAAjD,IACAT,oBAAoB,KAAK,KAAK,CAD9B,GAEIA,oBAFJ,GAGI,CAACU,IAAD,EAAOC,SAAP,KACET,UAAU,CACR,CAAC,GAAGrB,oBAAoB,CAAC+B,mBAAzB,EAA8CF,IAA9C,EAAoDC,SAApD,CADQ,CALlB;AAQA,SAAKE,UAAL,GAAkB,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBjB,MAAM,CAACgB,UAA/B,CAAlB;AACA,SAAKE,OAAL,GAAelB,MAAM,CAACkB,OAAtB;AACA,SAAKC,iBAAL,GACE,CAACf,qBAAqB,GAAGJ,MAAM,CAACmB,iBAAhC,MAAuD,IAAvD,IACAf,qBAAqB,KAAK,KAAK,CAD/B,GAEIA,qBAFJ,GAGI,EAJN;AAKAJ,IAAAA,MAAM,CAACU,cAAP,IAAyB,IAAzB,IACE,OAAOV,MAAM,CAACU,cAAd,KAAiC,QADnC,IAEE,CAAC,GAAGzC,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAE,KAAKe,IAAK,8CAAb,GACG,YAAW,CAAC,GAAGlC,QAAQ,CAACe,OAAb,EAAsBY,MAAM,CAACU,cAA7B,CAA6C,GAH7D,CAFF;AAOAV,IAAAA,MAAM,CAACW,SAAP,IAAoB,IAApB,IACE,OAAOX,MAAM,CAACW,SAAd,KAA4B,UAD9B,IAEE,CAAC,GAAG1C,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAE,KAAKe,IAAK,8JAFf,CAFF;;AAOA,QAAIP,MAAM,CAACY,YAAX,EAAyB;AACtB,aAAOZ,MAAM,CAACK,UAAd,KAA6B,UAA7B,IACC,OAAOL,MAAM,CAACY,YAAd,KAA+B,UADjC,IAEE,CAAC,GAAG3C,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAE,KAAKe,IAAK,+DAFf,CAFF;AAMD;AACF;;AAEsB,OAAlBd,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,mBAAP;AACD;;AAED0B,EAAAA,QAAQ,GAAG;AACT,WAAO;AACLb,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELE,MAAAA,WAAW,EAAE,KAAKA,WAFb;AAGLC,MAAAA,cAAc,EAAE,KAAKA,cAHhB;AAILC,MAAAA,SAAS,EAAE,KAAKA,SAJX;AAKLN,MAAAA,UAAU,EAAE,KAAKA,UALZ;AAMLO,MAAAA,YAAY,EAAE,KAAKA,YANd;AAOLI,MAAAA,UAAU,EAAE,KAAKA,UAPZ;AAQLE,MAAAA,OAAO,EAAE,KAAKA,OART;AASLC,MAAAA,iBAAiB,EAAE,KAAKA;AATnB,KAAP;AAWD;;AAEDxB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKY,IAAZ;AACD;;AAEDV,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AApFqB;;AAuFxB9E,OAAO,CAACG,iBAAR,GAA4BA,iBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAN,CAAwB;AACtBsE,EAAAA,WAAW,CAACS,MAAD,EAAS;AAClB,QAAIqB,sBAAJ;;AAEA,SAAKd,IAAL,GAAY,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BR,MAAM,CAACO,IAAnC,CAAZ;AACA,SAAKE,WAAL,GAAmBT,MAAM,CAACS,WAA1B;AACA,SAAKa,QAAL,GAAgBtB,MAAM,CAACsB,QAAvB;AACA,SAAKN,UAAL,GAAkB,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBjB,MAAM,CAACgB,UAA/B,CAAlB;AACA,SAAKE,OAAL,GAAelB,MAAM,CAACkB,OAAtB;AACA,SAAKC,iBAAL,GACE,CAACE,sBAAsB,GAAGrB,MAAM,CAACmB,iBAAjC,MAAwD,IAAxD,IACAE,sBAAsB,KAAK,KAAK,CADhC,GAEIA,sBAFJ,GAGI,EAJN;;AAMA,SAAKE,OAAL,GAAe,MAAMC,cAAc,CAACxB,MAAD,CAAnC;;AAEA,SAAKyB,WAAL,GAAmB,MAAMC,gBAAgB,CAAC1B,MAAD,CAAzC;;AAEAA,IAAAA,MAAM,CAACsB,QAAP,IAAmB,IAAnB,IACE,OAAOtB,MAAM,CAACsB,QAAd,KAA2B,UAD7B,IAEE,CAAC,GAAGrD,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAE,KAAKe,IAAK,0CAAb,GACG,YAAW,CAAC,GAAGlC,QAAQ,CAACe,OAAb,EAAsBY,MAAM,CAACsB,QAA7B,CAAuC,GAHvD,CAFF;AAOD;;AAEsB,OAAlB7B,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,mBAAP;AACD;;AAEDiC,EAAAA,SAAS,GAAG;AACV,QAAI,OAAO,KAAKJ,OAAZ,KAAwB,UAA5B,EAAwC;AACtC,WAAKA,OAAL,GAAe,KAAKA,OAAL,EAAf;AACD;;AAED,WAAO,KAAKA,OAAZ;AACD;;AAEDK,EAAAA,aAAa,GAAG;AACd,QAAI,OAAO,KAAKH,WAAZ,KAA4B,UAAhC,EAA4C;AAC1C,WAAKA,WAAL,GAAmB,KAAKA,WAAL,EAAnB;AACD;;AAED,WAAO,KAAKA,WAAZ;AACD;;AAEDL,EAAAA,QAAQ,GAAG;AACT,WAAO;AACLb,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELE,MAAAA,WAAW,EAAE,KAAKA,WAFb;AAGLoB,MAAAA,UAAU,EAAE,KAAKD,aAAL,EAHP;AAILE,MAAAA,MAAM,EAAEC,oBAAoB,CAAC,KAAKJ,SAAL,EAAD,CAJvB;AAKLL,MAAAA,QAAQ,EAAE,KAAKA,QALV;AAMLN,MAAAA,UAAU,EAAE,KAAKA,UANZ;AAOLE,MAAAA,OAAO,EAAE,KAAKA,OAPT;AAQLC,MAAAA,iBAAiB,EAAE,KAAKA;AARnB,KAAP;AAUD;;AAEDxB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKY,IAAZ;AACD;;AAEDV,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AAnEqB;;AAsExB9E,OAAO,CAACI,iBAAR,GAA4BA,iBAA5B;;AAEA,SAASyG,gBAAT,CAA0B1B,MAA1B,EAAkC;AAChC,MAAIgC,kBAAJ;;AAEA,QAAMH,UAAU,GAAG7D,yBAAyB,CAC1C,CAACgE,kBAAkB,GAAGhC,MAAM,CAAC6B,UAA7B,MAA6C,IAA7C,IACEG,kBAAkB,KAAK,KAAK,CAD9B,GAEIA,kBAFJ,GAGI,EAJsC,CAA5C;AAMAC,EAAAA,KAAK,CAACC,OAAN,CAAcL,UAAd,KACE,CAAC,GAAG5D,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,oEAFjB,CADF;AAKA,SAAOsB,UAAP;AACD;;AAED,SAASL,cAAT,CAAwBxB,MAAxB,EAAgC;AAC9B,QAAMmC,QAAQ,GAAGpE,kBAAkB,CAACiC,MAAM,CAAC8B,MAAR,CAAnC;AACAM,EAAAA,UAAU,CAACD,QAAD,CAAV,IACE,CAAC,GAAGlE,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,gGAFjB,CADF;AAKA,SAAO,CAAC,GAAG7B,SAAS,CAAC2D,QAAd,EAAwBF,QAAxB,EAAkC,CAACG,WAAD,EAAcC,SAAd,KAA4B;AACnE,QAAIC,iBAAJ;;AAEAJ,IAAAA,UAAU,CAACE,WAAD,CAAV,IACE,CAAC,GAAGrE,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,IAAGgC,SAAU,kCAF9B,CADF;AAKAD,IAAAA,WAAW,CAACG,OAAZ,IAAuB,IAAvB,IACE,OAAOH,WAAW,CAACG,OAAnB,KAA+B,UADjC,IAEE,CAAC,GAAGxE,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,IAAGgC,SAAU,wCAA5B,GACG,sBAAqB,CAAC,GAAGlE,QAAQ,CAACe,OAAb,EAAsBkD,WAAW,CAACG,OAAlC,CAA2C,GAHrE,CAFF;AAOA,UAAMC,UAAU,GACd,CAACF,iBAAiB,GAAGF,WAAW,CAACK,IAAjC,MAA2C,IAA3C,IACAH,iBAAiB,KAAK,KAAK,CAD3B,GAEIA,iBAFJ,GAGI,EAJN;AAKAJ,IAAAA,UAAU,CAACM,UAAD,CAAV,IACE,CAAC,GAAGzE,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,IAAGgC,SAAU,sDAF9B,CADF;AAKA,WAAO;AACLhC,MAAAA,IAAI,EAAE,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4B+B,SAA5B,CADD;AAEL9B,MAAAA,WAAW,EAAE6B,WAAW,CAAC7B,WAFpB;AAGLvB,MAAAA,IAAI,EAAEoD,WAAW,CAACpD,IAHb;AAILyD,MAAAA,IAAI,EAAElG,eAAe,CAACiG,UAAD,CAJhB;AAKLD,MAAAA,OAAO,EAAEH,WAAW,CAACG,OALhB;AAMLG,MAAAA,SAAS,EAAEN,WAAW,CAACM,SANlB;AAOLC,MAAAA,iBAAiB,EAAEP,WAAW,CAACO,iBAP1B;AAQL7B,MAAAA,UAAU,EAAE,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBqB,WAAW,CAACtB,UAApC,CARP;AASLE,MAAAA,OAAO,EAAEoB,WAAW,CAACpB;AAThB,KAAP;AAWD,GApCM,CAAP;AAqCD;;AAED,SAASzE,eAAT,CAAyBuD,MAAzB,EAAiC;AAC/B,SAAOrF,MAAM,CAACmI,OAAP,CAAe9C,MAAf,EAAuB+C,GAAvB,CAA2B;AAAA,QAAC,CAACC,OAAD,EAAUC,SAAV,CAAD;AAAA,WAA2B;AAC3D1C,MAAAA,IAAI,EAAE,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BwC,OAA5B,CADqD;AAE3DvC,MAAAA,WAAW,EAAEwC,SAAS,CAACxC,WAFoC;AAG3DvB,MAAAA,IAAI,EAAE+D,SAAS,CAAC/D,IAH2C;AAI3DgE,MAAAA,YAAY,EAAED,SAAS,CAACC,YAJmC;AAK3DL,MAAAA,iBAAiB,EAAEI,SAAS,CAACJ,iBAL8B;AAM3D7B,MAAAA,UAAU,EAAE,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBgC,SAAS,CAACjC,UAAlC,CAN+C;AAO3DE,MAAAA,OAAO,EAAE+B,SAAS,CAAC/B;AAPwC,KAA3B;AAAA,GAA3B,CAAP;AASD;;AAED,SAASkB,UAAT,CAAoBe,GAApB,EAAyB;AACvB,SAAO,CAAC,GAAG5E,aAAa,CAAC6E,YAAlB,EAAgCD,GAAhC,KAAwC,CAAClB,KAAK,CAACC,OAAN,CAAciB,GAAd,CAAhD;AACD;;AAED,SAASpB,oBAAT,CAA8BD,MAA9B,EAAsC;AACpC,SAAO,CAAC,GAAGpD,SAAS,CAAC2D,QAAd,EAAwBP,MAAxB,EAAiCuB,KAAD,KAAY;AACjD5C,IAAAA,WAAW,EAAE4C,KAAK,CAAC5C,WAD8B;AAEjDvB,IAAAA,IAAI,EAAEmE,KAAK,CAACnE,IAFqC;AAGjDyD,IAAAA,IAAI,EAAEpH,gBAAgB,CAAC8H,KAAK,CAACV,IAAP,CAH2B;AAIjDF,IAAAA,OAAO,EAAEY,KAAK,CAACZ,OAJkC;AAKjDG,IAAAA,SAAS,EAAES,KAAK,CAACT,SALgC;AAMjDC,IAAAA,iBAAiB,EAAEQ,KAAK,CAACR,iBANwB;AAOjD7B,IAAAA,UAAU,EAAEqC,KAAK,CAACrC,UAP+B;AAQjDE,IAAAA,OAAO,EAAEmC,KAAK,CAACnC;AARkC,GAAZ,CAAhC,CAAP;AAUD;AACD;AACA;AACA;;;AAEA,SAAS3F,gBAAT,CAA0BoH,IAA1B,EAAgC;AAC9B,SAAO,CAAC,GAAGlE,UAAU,CAAC6E,SAAf,EACLX,IADK,EAEJY,GAAD,IAASA,GAAG,CAAChD,IAFR,EAGJgD,GAAD,KAAU;AACR9C,IAAAA,WAAW,EAAE8C,GAAG,CAAC9C,WADT;AAERvB,IAAAA,IAAI,EAAEqE,GAAG,CAACrE,IAFF;AAGRgE,IAAAA,YAAY,EAAEK,GAAG,CAACL,YAHV;AAIRL,IAAAA,iBAAiB,EAAEU,GAAG,CAACV,iBAJf;AAKR7B,IAAAA,UAAU,EAAEuC,GAAG,CAACvC,UALR;AAMRE,IAAAA,OAAO,EAAEqC,GAAG,CAACrC;AANL,GAAV,CAHK,CAAP;AAYD;;AAED,SAASzD,kBAAT,CAA4B8F,GAA5B,EAAiC;AAC/B,SAAOlG,aAAa,CAACkG,GAAG,CAACrE,IAAL,CAAb,IAA2BqE,GAAG,CAACL,YAAJ,KAAqBM,SAAvD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMpI,oBAAN,CAA2B;AACzBmE,EAAAA,WAAW,CAACS,MAAD,EAAS;AAClB,QAAIyD,sBAAJ;;AAEA,SAAKlD,IAAL,GAAY,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BR,MAAM,CAACO,IAAnC,CAAZ;AACA,SAAKE,WAAL,GAAmBT,MAAM,CAACS,WAA1B;AACA,SAAKiD,WAAL,GAAmB1D,MAAM,CAAC0D,WAA1B;AACA,SAAK1C,UAAL,GAAkB,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBjB,MAAM,CAACgB,UAA/B,CAAlB;AACA,SAAKE,OAAL,GAAelB,MAAM,CAACkB,OAAtB;AACA,SAAKC,iBAAL,GACE,CAACsC,sBAAsB,GAAGzD,MAAM,CAACmB,iBAAjC,MAAwD,IAAxD,IACAsC,sBAAsB,KAAK,KAAK,CADhC,GAEIA,sBAFJ,GAGI,EAJN;AAKA,SAAKlC,OAAL,GAAeC,cAAc,CAACmC,IAAf,CAAoBH,SAApB,EAA+BxD,MAA/B,CAAf;AACA,SAAKyB,WAAL,GAAmBC,gBAAgB,CAACiC,IAAjB,CAAsBH,SAAtB,EAAiCxD,MAAjC,CAAnB;AACAA,IAAAA,MAAM,CAAC0D,WAAP,IAAsB,IAAtB,IACE,OAAO1D,MAAM,CAAC0D,WAAd,KAA8B,UADhC,IAEE,CAAC,GAAGzF,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAE,KAAKe,IAAK,6CAAb,GACG,YAAW,CAAC,GAAGlC,QAAQ,CAACe,OAAb,EAAsBY,MAAM,CAAC0D,WAA7B,CAA0C,GAH1D,CAFF;AAOD;;AAEsB,OAAlBjE,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,sBAAP;AACD;;AAEDiC,EAAAA,SAAS,GAAG;AACV,QAAI,OAAO,KAAKJ,OAAZ,KAAwB,UAA5B,EAAwC;AACtC,WAAKA,OAAL,GAAe,KAAKA,OAAL,EAAf;AACD;;AAED,WAAO,KAAKA,OAAZ;AACD;;AAEDK,EAAAA,aAAa,GAAG;AACd,QAAI,OAAO,KAAKH,WAAZ,KAA4B,UAAhC,EAA4C;AAC1C,WAAKA,WAAL,GAAmB,KAAKA,WAAL,EAAnB;AACD;;AAED,WAAO,KAAKA,WAAZ;AACD;;AAEDL,EAAAA,QAAQ,GAAG;AACT,WAAO;AACLb,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELE,MAAAA,WAAW,EAAE,KAAKA,WAFb;AAGLoB,MAAAA,UAAU,EAAE,KAAKD,aAAL,EAHP;AAILE,MAAAA,MAAM,EAAEC,oBAAoB,CAAC,KAAKJ,SAAL,EAAD,CAJvB;AAKL+B,MAAAA,WAAW,EAAE,KAAKA,WALb;AAML1C,MAAAA,UAAU,EAAE,KAAKA,UANZ;AAOLE,MAAAA,OAAO,EAAE,KAAKA,OAPT;AAQLC,MAAAA,iBAAiB,EAAE,KAAKA;AARnB,KAAP;AAUD;;AAEDxB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKY,IAAZ;AACD;;AAEDV,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AAhEwB;;AAmE3B9E,OAAO,CAACO,oBAAR,GAA+BA,oBAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAML,gBAAN,CAAuB;AACrBwE,EAAAA,WAAW,CAACS,MAAD,EAAS;AAClB,QAAI4D,sBAAJ;;AAEA,SAAKrD,IAAL,GAAY,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BR,MAAM,CAACO,IAAnC,CAAZ;AACA,SAAKE,WAAL,GAAmBT,MAAM,CAACS,WAA1B;AACA,SAAKiD,WAAL,GAAmB1D,MAAM,CAAC0D,WAA1B;AACA,SAAK1C,UAAL,GAAkB,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBjB,MAAM,CAACgB,UAA/B,CAAlB;AACA,SAAKE,OAAL,GAAelB,MAAM,CAACkB,OAAtB;AACA,SAAKC,iBAAL,GACE,CAACyC,sBAAsB,GAAG5D,MAAM,CAACmB,iBAAjC,MAAwD,IAAxD,IACAyC,sBAAsB,KAAK,KAAK,CADhC,GAEIA,sBAFJ,GAGI,EAJN;AAKA,SAAKC,MAAL,GAAcC,WAAW,CAACH,IAAZ,CAAiBH,SAAjB,EAA4BxD,MAA5B,CAAd;AACAA,IAAAA,MAAM,CAAC0D,WAAP,IAAsB,IAAtB,IACE,OAAO1D,MAAM,CAAC0D,WAAd,KAA8B,UADhC,IAEE,CAAC,GAAGzF,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAE,KAAKe,IAAK,6CAAb,GACG,YAAW,CAAC,GAAGlC,QAAQ,CAACe,OAAb,EAAsBY,MAAM,CAAC0D,WAA7B,CAA0C,GAH1D,CAFF;AAOD;;AAEsB,OAAlBjE,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,kBAAP;AACD;;AAEDqE,EAAAA,QAAQ,GAAG;AACT,QAAI,OAAO,KAAKF,MAAZ,KAAuB,UAA3B,EAAuC;AACrC,WAAKA,MAAL,GAAc,KAAKA,MAAL,EAAd;AACD;;AAED,WAAO,KAAKA,MAAZ;AACD;;AAEDzC,EAAAA,QAAQ,GAAG;AACT,WAAO;AACLb,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELE,MAAAA,WAAW,EAAE,KAAKA,WAFb;AAGLuD,MAAAA,KAAK,EAAE,KAAKD,QAAL,EAHF;AAILL,MAAAA,WAAW,EAAE,KAAKA,WAJb;AAKL1C,MAAAA,UAAU,EAAE,KAAKA,UALZ;AAMLE,MAAAA,OAAO,EAAE,KAAKA,OANT;AAOLC,MAAAA,iBAAiB,EAAE,KAAKA;AAPnB,KAAP;AASD;;AAEDxB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKY,IAAZ;AACD;;AAEDV,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AAtDoB;;AAyDvB9E,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B;;AAEA,SAAS+I,WAAT,CAAqB9D,MAArB,EAA6B;AAC3B,QAAMgE,KAAK,GAAGhG,yBAAyB,CAACgC,MAAM,CAACgE,KAAR,CAAvC;AACA/B,EAAAA,KAAK,CAACC,OAAN,CAAc8B,KAAd,KACE,CAAC,GAAG/F,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,mFAAkFQ,MAAM,CAACO,IAAK,GAFjG,CADF;AAKA,SAAOyD,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM1I,eAAN,CAAsB;AACpB;AACAiE,EAAAA,WAAW,CAACS,MAAD,EAAS;AAClB,QAAIiE,sBAAJ;;AAEA,SAAK1D,IAAL,GAAY,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BR,MAAM,CAACO,IAAnC,CAAZ;AACA,SAAKE,WAAL,GAAmBT,MAAM,CAACS,WAA1B;AACA,SAAKO,UAAL,GAAkB,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBjB,MAAM,CAACgB,UAA/B,CAAlB;AACA,SAAKE,OAAL,GAAelB,MAAM,CAACkB,OAAtB;AACA,SAAKC,iBAAL,GACE,CAAC8C,sBAAsB,GAAGjE,MAAM,CAACmB,iBAAjC,MAAwD,IAAxD,IACA8C,sBAAsB,KAAK,KAAK,CADhC,GAEIA,sBAFJ,GAGI,EAJN;AAKA,SAAKC,OAAL,GAAeC,gBAAgB,CAAC,KAAK5D,IAAN,EAAYP,MAAM,CAACoE,MAAnB,CAA/B;AACA,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,CAClB,KAAKJ,OAAL,CAAanB,GAAb,CAAkBwB,SAAD,IAAe,CAACA,SAAS,CAACzJ,KAAX,EAAkByJ,SAAlB,CAAhC,CADkB,CAApB;AAGA,SAAKC,WAAL,GAAmB,CAAC,GAAGhG,OAAO,CAACiG,MAAZ,EAAoB,KAAKP,OAAzB,EAAmCpJ,KAAD,IAAWA,KAAK,CAACyF,IAAnD,CAAnB;AACD;;AAEsB,OAAlBd,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,iBAAP;AACD;;AAEDgF,EAAAA,SAAS,GAAG;AACV,WAAO,KAAKR,OAAZ;AACD;;AAEDS,EAAAA,QAAQ,CAACpE,IAAD,EAAO;AACb,WAAO,KAAKiE,WAAL,CAAiBjE,IAAjB,CAAP;AACD;;AAEDI,EAAAA,SAAS,CAACiE,WAAD,EAAc;AACrB,UAAML,SAAS,GAAG,KAAKF,YAAL,CAAkBQ,GAAlB,CAAsBD,WAAtB,CAAlB;;AAEA,QAAIL,SAAS,KAAKf,SAAlB,EAA6B;AAC3B,YAAM,IAAI3E,aAAa,CAACiG,YAAlB,CACH,SAAQ,KAAKvE,IAAK,6BAA4B,CAAC,GAAGlC,QAAQ,CAACe,OAAb,EAC7CwF,WAD6C,CAE7C,EAHE,CAAN;AAKD;;AAED,WAAOL,SAAS,CAAChE,IAAjB;AACD;;AAEDF,EAAAA,UAAU,CAAC0E,UAAD;AAAa;AACvB;AACE,QAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAClC,YAAMC,QAAQ,GAAG,CAAC,GAAG3G,QAAQ,CAACe,OAAb,EAAsB2F,UAAtB,CAAjB;AACA,YAAM,IAAIlG,aAAa,CAACiG,YAAlB,CACH,SAAQ,KAAKvE,IAAK,wCAAuCyE,QAAS,GAAnE,GACEC,mBAAmB,CAAC,IAAD,EAAOD,QAAP,CAFjB,CAAN;AAID;;AAED,UAAMT,SAAS,GAAG,KAAKI,QAAL,CAAcI,UAAd,CAAlB;;AAEA,QAAIR,SAAS,IAAI,IAAjB,EAAuB;AACrB,YAAM,IAAI1F,aAAa,CAACiG,YAAlB,CACH,UAASC,UAAW,wBAAuB,KAAKxE,IAAK,SAAtD,GACE0E,mBAAmB,CAAC,IAAD,EAAOF,UAAP,CAFjB,CAAN;AAID;;AAED,WAAOR,SAAS,CAACzJ,KAAjB;AACD;;AAED8F,EAAAA,YAAY,CAACsE,SAAD,EAAYC,UAAZ;AAAwB;AACpC;AACE;AACA,QAAID,SAAS,CAACE,IAAV,KAAmBtG,MAAM,CAACuG,IAAP,CAAYC,IAAnC,EAAyC;AACvC,YAAMN,QAAQ,GAAG,CAAC,GAAGjG,QAAQ,CAACwG,KAAb,EAAoBL,SAApB,CAAjB;AACA,YAAM,IAAIrG,aAAa,CAACiG,YAAlB,CACH,SAAQ,KAAKvE,IAAK,sCAAqCyE,QAAS,GAAjE,GACEC,mBAAmB,CAAC,IAAD,EAAOD,QAAP,CAFjB,EAGJ;AACEQ,QAAAA,KAAK,EAAEN;AADT,OAHI,CAAN;AAOD;;AAED,UAAMX,SAAS,GAAG,KAAKI,QAAL,CAAcO,SAAS,CAACpK,KAAxB,CAAlB;;AAEA,QAAIyJ,SAAS,IAAI,IAAjB,EAAuB;AACrB,YAAMS,QAAQ,GAAG,CAAC,GAAGjG,QAAQ,CAACwG,KAAb,EAAoBL,SAApB,CAAjB;AACA,YAAM,IAAIrG,aAAa,CAACiG,YAAlB,CACH,UAASE,QAAS,wBAAuB,KAAKzE,IAAK,SAApD,GACE0E,mBAAmB,CAAC,IAAD,EAAOD,QAAP,CAFjB,EAGJ;AACEQ,QAAAA,KAAK,EAAEN;AADT,OAHI,CAAN;AAOD;;AAED,WAAOX,SAAS,CAACzJ,KAAjB;AACD;;AAEDsG,EAAAA,QAAQ,GAAG;AACT,UAAMgD,MAAM,GAAG,CAAC,GAAG3F,UAAU,CAAC6E,SAAf,EACb,KAAKoB,SAAL,EADa,EAEZ5J,KAAD,IAAWA,KAAK,CAACyF,IAFJ,EAGZzF,KAAD,KAAY;AACV2F,MAAAA,WAAW,EAAE3F,KAAK,CAAC2F,WADT;AAEV3F,MAAAA,KAAK,EAAEA,KAAK,CAACA,KAFH;AAGV+H,MAAAA,iBAAiB,EAAE/H,KAAK,CAAC+H,iBAHf;AAIV7B,MAAAA,UAAU,EAAElG,KAAK,CAACkG,UAJR;AAKVE,MAAAA,OAAO,EAAEpG,KAAK,CAACoG;AALL,KAAZ,CAHa,CAAf;AAWA,WAAO;AACLX,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELE,MAAAA,WAAW,EAAE,KAAKA,WAFb;AAGL2D,MAAAA,MAHK;AAILpD,MAAAA,UAAU,EAAE,KAAKA,UAJZ;AAKLE,MAAAA,OAAO,EAAE,KAAKA,OALT;AAMLC,MAAAA,iBAAiB,EAAE,KAAKA;AANnB,KAAP;AAQD;;AAEDxB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKY,IAAZ;AACD;;AAEDV,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AA/HmB;;AAkItB9E,OAAO,CAACS,eAAR,GAA0BA,eAA1B;;AAEA,SAAS2J,mBAAT,CAA6BQ,QAA7B,EAAuCC,eAAvC,EAAwD;AACtD,QAAMC,QAAQ,GAAGF,QAAQ,CAACf,SAAT,GAAqB3B,GAArB,CAA0BjI,KAAD,IAAWA,KAAK,CAACyF,IAA1C,CAAjB;AACA,QAAMqF,eAAe,GAAG,CAAC,GAAGjH,eAAe,CAACkH,cAApB,EACtBH,eADsB,EAEtBC,QAFsB,CAAxB;AAIA,SAAO,CAAC,GAAGxH,WAAW,CAAC2H,UAAhB,EAA4B,gBAA5B,EAA8CF,eAA9C,CAAP;AACD;;AAED,SAASzB,gBAAT,CAA0B4B,QAA1B,EAAoCC,QAApC,EAA8C;AAC5C5D,EAAAA,UAAU,CAAC4D,QAAD,CAAV,IACE,CAAC,GAAG/H,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEuG,QAAS,qDAFd,CADF;AAKA,SAAOpL,MAAM,CAACmI,OAAP,CAAekD,QAAf,EAAyBjD,GAAzB,CAA6B,SAA8B;AAAA,QAA7B,CAACkD,SAAD,EAAYC,WAAZ,CAA6B;AAChE9D,IAAAA,UAAU,CAAC8D,WAAD,CAAV,IACE,CAAC,GAAGjI,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEuG,QAAS,IAAGE,SAAU,8CAAzB,GACG,2CAA0C,CAAC,GAAG5H,QAAQ,CAACe,OAAb,EACzC8G,WADyC,CAEzC,GALN,CADF;AAQA,WAAO;AACL3F,MAAAA,IAAI,EAAE,CAAC,GAAGtB,WAAW,CAACkH,mBAAhB,EAAqCF,SAArC,CADD;AAELxF,MAAAA,WAAW,EAAEyF,WAAW,CAACzF,WAFpB;AAGL3F,MAAAA,KAAK,EAAEoL,WAAW,CAACpL,KAAZ,KAAsB0I,SAAtB,GAAkC0C,WAAW,CAACpL,KAA9C,GAAsDmL,SAHxD;AAILpD,MAAAA,iBAAiB,EAAEqD,WAAW,CAACrD,iBAJ1B;AAKL7B,MAAAA,UAAU,EAAE,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBiF,WAAW,CAAClF,UAApC,CALP;AAMLE,MAAAA,OAAO,EAAEgF,WAAW,CAAChF;AANhB,KAAP;AAQD,GAjBM,CAAP;AAkBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM7F,sBAAN,CAA6B;AAC3BkE,EAAAA,WAAW,CAACS,MAAD,EAAS;AAClB,QAAIoG,sBAAJ;;AAEA,SAAK7F,IAAL,GAAY,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4BR,MAAM,CAACO,IAAnC,CAAZ;AACA,SAAKE,WAAL,GAAmBT,MAAM,CAACS,WAA1B;AACA,SAAKO,UAAL,GAAkB,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBjB,MAAM,CAACgB,UAA/B,CAAlB;AACA,SAAKE,OAAL,GAAelB,MAAM,CAACkB,OAAtB;AACA,SAAKC,iBAAL,GACE,CAACiF,sBAAsB,GAAGpG,MAAM,CAACmB,iBAAjC,MAAwD,IAAxD,IACAiF,sBAAsB,KAAK,KAAK,CADhC,GAEIA,sBAFJ,GAGI,EAJN;AAKA,SAAK7E,OAAL,GAAe8E,mBAAmB,CAAC1C,IAApB,CAAyBH,SAAzB,EAAoCxD,MAApC,CAAf;AACD;;AAEsB,OAAlBP,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,wBAAP;AACD;;AAEDiC,EAAAA,SAAS,GAAG;AACV,QAAI,OAAO,KAAKJ,OAAZ,KAAwB,UAA5B,EAAwC;AACtC,WAAKA,OAAL,GAAe,KAAKA,OAAL,EAAf;AACD;;AAED,WAAO,KAAKA,OAAZ;AACD;;AAEDH,EAAAA,QAAQ,GAAG;AACT,UAAMU,MAAM,GAAG,CAAC,GAAGpD,SAAS,CAAC2D,QAAd,EAAwB,KAAKV,SAAL,EAAxB,EAA2C0B,KAAD,KAAY;AACnE5C,MAAAA,WAAW,EAAE4C,KAAK,CAAC5C,WADgD;AAEnEvB,MAAAA,IAAI,EAAEmE,KAAK,CAACnE,IAFuD;AAGnEgE,MAAAA,YAAY,EAAEG,KAAK,CAACH,YAH+C;AAInEL,MAAAA,iBAAiB,EAAEQ,KAAK,CAACR,iBAJ0C;AAKnE7B,MAAAA,UAAU,EAAEqC,KAAK,CAACrC,UALiD;AAMnEE,MAAAA,OAAO,EAAEmC,KAAK,CAACnC;AANoD,KAAZ,CAA1C,CAAf;AAQA,WAAO;AACLX,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELE,MAAAA,WAAW,EAAE,KAAKA,WAFb;AAGLqB,MAAAA,MAHK;AAILd,MAAAA,UAAU,EAAE,KAAKA,UAJZ;AAKLE,MAAAA,OAAO,EAAE,KAAKA,OALT;AAMLC,MAAAA,iBAAiB,EAAE,KAAKA;AANnB,KAAP;AAQD;;AAEDxB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKY,IAAZ;AACD;;AAEDV,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKF,QAAL,EAAP;AACD;;AArD0B;;AAwD7B9E,OAAO,CAACQ,sBAAR,GAAiCA,sBAAjC;;AAEA,SAASgL,mBAAT,CAA6BrG,MAA7B,EAAqC;AACnC,QAAMmC,QAAQ,GAAGpE,kBAAkB,CAACiC,MAAM,CAAC8B,MAAR,CAAnC;AACAM,EAAAA,UAAU,CAACD,QAAD,CAAV,IACE,CAAC,GAAGlE,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,gGAFjB,CADF;AAKA,SAAO,CAAC,GAAG7B,SAAS,CAAC2D,QAAd,EAAwBF,QAAxB,EAAkC,CAACG,WAAD,EAAcC,SAAd,KAA4B;AACnE,MAAE,aAAaD,WAAf,KACE,CAAC,GAAGrE,UAAU,CAACuB,SAAf,EACE,KADF,EAEG,GAAEQ,MAAM,CAACO,IAAK,IAAGgC,SAAU,yEAF9B,CADF;AAKA,WAAO;AACLhC,MAAAA,IAAI,EAAE,CAAC,GAAGtB,WAAW,CAACuB,UAAhB,EAA4B+B,SAA5B,CADD;AAEL9B,MAAAA,WAAW,EAAE6B,WAAW,CAAC7B,WAFpB;AAGLvB,MAAAA,IAAI,EAAEoD,WAAW,CAACpD,IAHb;AAILgE,MAAAA,YAAY,EAAEZ,WAAW,CAACY,YAJrB;AAKLL,MAAAA,iBAAiB,EAAEP,WAAW,CAACO,iBAL1B;AAML7B,MAAAA,UAAU,EAAE,CAAC,GAAGpC,SAAS,CAACqC,QAAd,EAAwBqB,WAAW,CAACtB,UAApC,CANP;AAOLE,MAAAA,OAAO,EAAEoB,WAAW,CAACpB;AAPhB,KAAP;AASD,GAfM,CAAP;AAgBD;;AAED,SAASxD,oBAAT,CAA8B2F,KAA9B,EAAqC;AACnC,SAAOhG,aAAa,CAACgG,KAAK,CAACnE,IAAP,CAAb,IAA6BmE,KAAK,CAACH,YAAN,KAAuBM,SAA3D;AACD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.GraphQLUnionType =\n  exports.GraphQLScalarType =\n  exports.GraphQLObjectType =\n  exports.GraphQLNonNull =\n  exports.GraphQLList =\n  exports.GraphQLInterfaceType =\n  exports.GraphQLInputObjectType =\n  exports.GraphQLEnumType =\n    void 0;\nexports.argsToArgsConfig = argsToArgsConfig;\nexports.assertAbstractType = assertAbstractType;\nexports.assertCompositeType = assertCompositeType;\nexports.assertEnumType = assertEnumType;\nexports.assertInputObjectType = assertInputObjectType;\nexports.assertInputType = assertInputType;\nexports.assertInterfaceType = assertInterfaceType;\nexports.assertLeafType = assertLeafType;\nexports.assertListType = assertListType;\nexports.assertNamedType = assertNamedType;\nexports.assertNonNullType = assertNonNullType;\nexports.assertNullableType = assertNullableType;\nexports.assertObjectType = assertObjectType;\nexports.assertOutputType = assertOutputType;\nexports.assertScalarType = assertScalarType;\nexports.assertType = assertType;\nexports.assertUnionType = assertUnionType;\nexports.assertWrappingType = assertWrappingType;\nexports.defineArguments = defineArguments;\nexports.getNamedType = getNamedType;\nexports.getNullableType = getNullableType;\nexports.isAbstractType = isAbstractType;\nexports.isCompositeType = isCompositeType;\nexports.isEnumType = isEnumType;\nexports.isInputObjectType = isInputObjectType;\nexports.isInputType = isInputType;\nexports.isInterfaceType = isInterfaceType;\nexports.isLeafType = isLeafType;\nexports.isListType = isListType;\nexports.isNamedType = isNamedType;\nexports.isNonNullType = isNonNullType;\nexports.isNullableType = isNullableType;\nexports.isObjectType = isObjectType;\nexports.isOutputType = isOutputType;\nexports.isRequiredArgument = isRequiredArgument;\nexports.isRequiredInputField = isRequiredInputField;\nexports.isScalarType = isScalarType;\nexports.isType = isType;\nexports.isUnionType = isUnionType;\nexports.isWrappingType = isWrappingType;\nexports.resolveObjMapThunk = resolveObjMapThunk;\nexports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _didYouMean = require('../jsutils/didYouMean.js');\n\nvar _identityFunc = require('../jsutils/identityFunc.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _instanceOf = require('../jsutils/instanceOf.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _keyValMap = require('../jsutils/keyValMap.js');\n\nvar _mapValue = require('../jsutils/mapValue.js');\n\nvar _suggestionList = require('../jsutils/suggestionList.js');\n\nvar _toObjMap = require('../jsutils/toObjMap.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _valueFromASTUntyped = require('../utilities/valueFromASTUntyped.js');\n\nvar _assertName = require('./assertName.js');\n\nfunction isType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    isListType(type) ||\n    isNonNullType(type)\n  );\n}\n\nfunction assertType(type) {\n  if (!isType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\nfunction isScalarType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);\n}\n\nfunction assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isObjectType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);\n}\n\nfunction assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isInterfaceType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);\n}\n\nfunction assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isUnionType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);\n}\n\nfunction assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isEnumType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);\n}\n\nfunction assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isInputObjectType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);\n}\n\nfunction assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(\n        type,\n      )} to be a GraphQL Input Object type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isListType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLList);\n}\n\nfunction assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction isNonNullType(type) {\n  return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);\n}\n\nfunction assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nfunction isInputType(type) {\n  return (\n    isScalarType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    (isWrappingType(type) && isInputType(type.ofType))\n  );\n}\n\nfunction assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nfunction isOutputType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    (isWrappingType(type) && isOutputType(type.ofType))\n  );\n}\n\nfunction assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nfunction isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\n\nfunction assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nfunction isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\n\nfunction assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nfunction isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\n\nfunction assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\n\nclass GraphQLList {\n  constructor(ofType) {\n    isType(ofType) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`,\n      );\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString() {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\nexports.GraphQLList = GraphQLList;\n\nclass GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `Expected ${(0, _inspect.inspect)(\n          ofType,\n        )} to be a GraphQL nullable type.`,\n      );\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString() {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n/**\n * These types wrap and modify other types\n */\n\nexports.GraphQLNonNull = GraphQLNonNull;\n\nfunction isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\n\nfunction assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nfunction isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\n\nfunction assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction getNullableType(type) {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nfunction isNamedType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type)\n  );\n}\n\nfunction assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`,\n    );\n  }\n\n  return type;\n}\n\nfunction getNamedType(type) {\n  if (type) {\n    let unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function returns `null` or does not return a value\n * (i.e. it returns `undefined`) then an error will be raised and a `null`\n * value will be returned in the response. It is always better to validate\n *\n * Example:\n *\n * ```ts\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   serialize(value) {\n *     if (!Number.isFinite(value)) {\n *       throw new Error(\n *         `Scalar \"Odd\" cannot represent \"${value}\" since it is not a finite number.`,\n *       );\n *     }\n *\n *     if (value % 2 === 0) {\n *       throw new Error(`Scalar \"Odd\" cannot represent \"${value}\" since it is even.`);\n *     }\n *     return value;\n *   }\n * });\n * ```\n */\nclass GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue,\n      _config$serialize,\n      _config$parseLiteral,\n      _config$extensionASTN;\n\n    const parseValue =\n      (_config$parseValue = config.parseValue) !== null &&\n      _config$parseValue !== void 0\n        ? _config$parseValue\n        : _identityFunc.identityFunc;\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize =\n      (_config$serialize = config.serialize) !== null &&\n      _config$serialize !== void 0\n        ? _config$serialize\n        : _identityFunc.identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral =\n      (_config$parseLiteral = config.parseLiteral) !== null &&\n      _config$parseLiteral !== void 0\n        ? _config$parseLiteral\n        : (node, variables) =>\n            parseValue(\n              (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables),\n            );\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    config.specifiedByURL == null ||\n      typeof config.specifiedByURL === 'string' ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${this.name} must provide \"specifiedByURL\" as a string, ` +\n          `but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`,\n      );\n    config.serialize == null ||\n      typeof config.serialize === 'function' ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`,\n      );\n\n    if (config.parseLiteral) {\n      (typeof config.parseValue === 'function' &&\n        typeof config.parseLiteral === 'function') ||\n        (0, _devAssert.devAssert)(\n          false,\n          `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`,\n        );\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexports.GraphQLScalarType = GraphQLScalarType;\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\nclass GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN2 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN2 !== void 0\n        ? _config$extensionASTN2\n        : [];\n\n    this._fields = () => defineFieldMap(config);\n\n    this._interfaces = () => defineInterfaces(config);\n\n    config.isTypeOf == null ||\n      typeof config.isTypeOf === 'function' ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${this.name} must provide \"isTypeOf\" as a function, ` +\n          `but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexports.GraphQLObjectType = GraphQLObjectType;\n\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n\n  const interfaces = resolveReadonlyArrayThunk(\n    (_config$interfaces = config.interfaces) !== null &&\n      _config$interfaces !== void 0\n      ? _config$interfaces\n      : [],\n  );\n  Array.isArray(interfaces) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `${config.name} interfaces must be an Array or a function which returns an Array.`,\n    );\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,\n    );\n  return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${config.name}.${fieldName} field config must be an object.`,\n      );\n    fieldConfig.resolve == null ||\n      typeof fieldConfig.resolve === 'function' ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${config.name}.${fieldName} field resolver must be a function if ` +\n          `provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`,\n      );\n    const argsConfig =\n      (_fieldConfig$args = fieldConfig.args) !== null &&\n      _fieldConfig$args !== void 0\n        ? _fieldConfig$args\n        : {};\n    isPlainObj(argsConfig) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${config.name}.${fieldName} args must be an object with argument names as keys.`,\n      );\n    return {\n      name: (0, _assertName.assertName)(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nfunction defineArguments(config) {\n  return Object.entries(config).map(([argName, argConfig]) => ({\n    name: (0, _assertName.assertName)(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),\n    astNode: argConfig.astNode,\n  }));\n}\n\nfunction isPlainObj(obj) {\n  return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return (0, _mapValue.mapValue)(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  }));\n}\n/**\n * @internal\n */\n\nfunction argsToArgsConfig(args) {\n  return (0, _keyValMap.keyValMap)(\n    args,\n    (arg) => arg.name,\n    (arg) => ({\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode,\n    }),\n  );\n}\n\nfunction isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\nclass GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN3 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN3 !== void 0\n        ? _config$extensionASTN3\n        : [];\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    config.resolveType == null ||\n      typeof config.resolveType === 'function' ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${this.name} must provide \"resolveType\" as a function, ` +\n          `but got: ${(0, _inspect.inspect)(config.resolveType)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexports.GraphQLInterfaceType = GraphQLInterfaceType;\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\nclass GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN4 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN4 !== void 0\n        ? _config$extensionASTN4\n        : [];\n    this._types = defineTypes.bind(undefined, config);\n    config.resolveType == null ||\n      typeof config.resolveType === 'function' ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${this.name} must provide \"resolveType\" as a function, ` +\n          `but got: ${(0, _inspect.inspect)(config.resolveType)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexports.GraphQLUnionType = GraphQLUnionType;\n\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `Must provide Array of types or a function which returns such an array for Union ${config.name}.`,\n    );\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nclass GraphQLEnumType {\n  /* <T> */\n  constructor(config) {\n    var _config$extensionASTN5;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN5 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN5 !== void 0\n        ? _config$extensionASTN5\n        : [];\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(\n      this._values.map((enumValue) => [enumValue.value, enumValue]),\n    );\n    this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues() {\n    return this._values;\n  }\n\n  getValue(name) {\n    return this._nameLookup[name];\n  }\n\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new _GraphQLError.GraphQLError(\n        `Enum \"${this.name}\" cannot represent value: ${(0, _inspect.inspect)(\n          outputValue,\n        )}`,\n      );\n    }\n\n    return enumValue.name;\n  }\n\n  parseValue(inputValue) /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      const valueStr = (0, _inspect.inspect)(inputValue);\n      throw new _GraphQLError.GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` +\n          didYouMeanEnumValue(this, valueStr),\n      );\n    }\n\n    const enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new _GraphQLError.GraphQLError(\n        `Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` +\n          didYouMeanEnumValue(this, inputValue),\n      );\n    }\n\n    return enumValue.value;\n  }\n\n  parseLiteral(valueNode, _variables) /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== _kinds.Kind.ENUM) {\n      const valueStr = (0, _printer.print)(valueNode);\n      throw new _GraphQLError.GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` +\n          didYouMeanEnumValue(this, valueStr),\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      const valueStr = (0, _printer.print)(valueNode);\n      throw new _GraphQLError.GraphQLError(\n        `Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` +\n          didYouMeanEnumValue(this, valueStr),\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    return enumValue.value;\n  }\n\n  toConfig() {\n    const values = (0, _keyValMap.keyValMap)(\n      this.getValues(),\n      (value) => value.name,\n      (value) => ({\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode,\n      }),\n    );\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexports.GraphQLEnumType = GraphQLEnumType;\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = (0, _suggestionList.suggestionList)(\n    unknownValueStr,\n    allNames,\n  );\n  return (0, _didYouMean.didYouMean)('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `${typeName} values must be an object with value names as keys.`,\n    );\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${typeName}.${valueName} must refer to an object with a \"value\" key ` +\n          `representing an internal value but got: ${(0, _inspect.inspect)(\n            valueConfig,\n          )}.`,\n      );\n    return {\n      name: (0, _assertName.assertEnumValueName)(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),\n      astNode: valueConfig.astNode,\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\nclass GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6;\n\n    this.name = (0, _assertName.assertName)(config.name);\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN6 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN6 !== void 0\n        ? _config$extensionASTN6\n        : [];\n    this._fields = defineInputFieldMap.bind(undefined, config);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  toConfig() {\n    const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode,\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexports.GraphQLInputObjectType = GraphQLInputObjectType;\n\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,\n    );\n  return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {\n    !('resolve' in fieldConfig) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`,\n      );\n    return {\n      name: (0, _assertName.assertName)(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nfunction isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n"]},"metadata":{},"sourceType":"script"}