{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.Parser = void 0;\nexports.parse = parse;\nexports.parseConstValue = parseConstValue;\nexports.parseType = parseType;\nexports.parseValue = parseValue;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _directiveLocation = require('./directiveLocation.js');\n\nvar _kinds = require('./kinds.js');\n\nvar _lexer = require('./lexer.js');\n\nvar _source = require('./source.js');\n\nvar _tokenKind = require('./tokenKind.js');\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\nfunction parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\n\nfunction parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\n\nfunction parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\n\nfunction parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\n\nclass Parser {\n  constructor(source, options) {\n    const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);\n    this._lexer = new _lexer.Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  parseName() {\n    const token = this.expectToken(_tokenKind.TokenKind.NAME);\n    return this.node(token, {\n      kind: _kinds.Kind.NAME,\n      value: token.value\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n\n  parseDefinition() {\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: _kinds.Kind.OPERATION_DEFINITION,\n        operation: _ast.OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n\n  parseOperationType() {\n    const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return _ast.OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return _ast.OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return _ast.OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n\n  parseVariableDefinitions() {\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n      directives: this.parseConstDirectives()\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: _kinds.Kind.VARIABLE,\n      name: this.parseName()\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.SELECTION_SET,\n      selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n\n  parseSelection() {\n    return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n\n  parseArgument() {\n    let isConst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false)\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case _tokenKind.TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case _tokenKind.TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case _tokenKind.TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: _kinds.Kind.INT,\n          value: token.value\n        });\n\n      case _tokenKind.TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: _kinds.Kind.FLOAT,\n          value: token.value\n        });\n\n      case _tokenKind.TokenKind.STRING:\n      case _tokenKind.TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case _tokenKind.TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: true\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: false\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: _kinds.Kind.NULL\n            });\n\n          default:\n            return this.node(token, {\n              kind: _kinds.Kind.ENUM,\n              value: token.value\n            });\n        }\n\n      case _tokenKind.TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(_tokenKind.TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable \"$${varName}\" in constant value.`);\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: _kinds.Kind.STRING,\n      value: token.value,\n      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.LIST,\n      values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.OBJECT,\n      fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(_tokenKind.TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.AT);\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst)\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(_tokenKind.TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: _kinds.Kind.LIST_TYPE,\n        type: innerType\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {\n      return this.node(start, {\n        kind: _kinds.Kind.NON_NULL_TYPE,\n        type\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.NAMED_TYPE,\n      name: this.parseName()\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n\n  peekDescription() {\n    return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements') ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n\n  parseFieldsDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n\n  parseArgumentDefs() {\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n\n  parseEnumValueName() {\n    if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n      throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(_tokenKind.TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {\n      node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected \"${value}\", found ${getTokenDesc(token)}.`);\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n\n  unexpected(atToken) {\n    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\n\nexports.Parser = Parser;\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return (0, _lexer.isPunctuatorTokenKind)(kind) ? `\"${kind}\"` : kind;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/language/parser.js"],"names":["Object","defineProperty","exports","value","Parser","parse","parseConstValue","parseType","parseValue","_syntaxError","require","_ast","_directiveLocation","_kinds","_lexer","_source","_tokenKind","source","options","parser","parseDocument","expectToken","TokenKind","SOF","parseValueLiteral","EOF","parseConstValueLiteral","type","parseTypeReference","constructor","sourceObj","isSource","Source","Lexer","_options","parseName","token","NAME","node","kind","Kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","syntaxError","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","OperationTypeNode","QUERY","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","BRACKET_R","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","prototype","hasOwnProperty","call","DirectiveLocation","startToken","_this$_options2","noLocation","loc","Location","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","isPunctuatorTokenKind"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.Parser = void 0;\nexports.parse = parse;\nexports.parseConstValue = parseConstValue;\nexports.parseType = parseType;\nexports.parseValue = parseValue;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _directiveLocation = require('./directiveLocation.js');\n\nvar _kinds = require('./kinds.js');\n\nvar _lexer = require('./lexer.js');\n\nvar _source = require('./source.js');\n\nvar _tokenKind = require('./tokenKind.js');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nfunction parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nfunction parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nfunction parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nclass Parser {\n  constructor(source, options) {\n    const sourceObj = (0, _source.isSource)(source)\n      ? source\n      : new _source.Source(source);\n    this._lexer = new _lexer.Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(_tokenKind.TokenKind.NAME);\n    return this.node(token, {\n      kind: _kinds.Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: this.many(\n        _tokenKind.TokenKind.SOF,\n        this.parseDefinition,\n        _tokenKind.TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw (0, _syntaxError.syntaxError)(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: _kinds.Kind.OPERATION_DEFINITION,\n        operation: _ast.OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return _ast.OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return _ast.OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return _ast.OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type:\n        (this.expectToken(_tokenKind.TokenKind.COLON),\n        this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: _kinds.Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.SELECTION_SET,\n      selections: this.many(\n        _tokenKind.TokenKind.BRACE_L,\n        this.parseSelection,\n        _tokenKind.TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(_tokenKind.TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      item,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case _tokenKind.TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case _tokenKind.TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case _tokenKind.TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: _kinds.Kind.INT,\n          value: token.value,\n        });\n\n      case _tokenKind.TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: _kinds.Kind.FLOAT,\n          value: token.value,\n        });\n\n      case _tokenKind.TokenKind.STRING:\n      case _tokenKind.TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case _tokenKind.TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: _kinds.Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: _kinds.Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case _tokenKind.TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(_tokenKind.TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw (0, _syntaxError.syntaxError)(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: _kinds.Kind.STRING,\n      value: token.value,\n      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.LIST,\n      values: this.any(\n        _tokenKind.TokenKind.BRACKET_L,\n        item,\n        _tokenKind.TokenKind.BRACKET_R,\n      ),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.OBJECT,\n      fields: this.any(\n        _tokenKind.TokenKind.BRACE_L,\n        item,\n        _tokenKind.TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(_tokenKind.TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.AT);\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(_tokenKind.TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: _kinds.Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {\n      return this.node(start, {\n        kind: _kinds.Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return (\n      this.peek(_tokenKind.TokenKind.STRING) ||\n      this.peek(_tokenKind.TokenKind.BLOCK_STRING)\n    );\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)\n      ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw (0, _syntaxError.syntaxError)(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(_tokenKind.TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(\n      _tokenKind.TokenKind.PIPE,\n      this.parseDirectiveLocation,\n    );\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (\n      Object.prototype.hasOwnProperty.call(\n        _directiveLocation.DirectiveLocation,\n        name.value,\n      )\n    ) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new _ast.Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw (0, _syntaxError.syntaxError)(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return (0, _syntaxError.syntaxError)(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nexports.Parser = Parser;\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return (0, _lexer.isPunctuatorTokenKind)(kind) ? `\"${kind}\"` : kind;\n}\n"]},"metadata":{},"sourceType":"script"}