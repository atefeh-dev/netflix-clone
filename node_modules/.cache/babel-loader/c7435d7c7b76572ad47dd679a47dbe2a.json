{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeComparators = require('../../utilities/typeComparators.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\n\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`, {\n          nodes: node\n        }));\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(new _GraphQLError.GraphQLError(`Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`, {\n          nodes: node\n        }));\n      }\n    }\n\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"],"names":["Object","defineProperty","exports","value","PossibleFragmentSpreadsRule","_inspect","require","_GraphQLError","_definition","_typeComparators","_typeFromAST","context","InlineFragment","node","fragType","getType","parentType","getParentType","isCompositeType","doTypesOverlap","getSchema","parentTypeStr","inspect","fragTypeStr","reportError","GraphQLError","nodes","FragmentSpread","fragName","name","getFragmentType","frag","getFragment","type","typeFromAST","typeCondition"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeComparators = require('../../utilities/typeComparators.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        (0, _definition.isCompositeType)(fragType) &&\n        (0, _definition.isCompositeType)(parentType) &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = (0, _typeFromAST.typeFromAST)(\n      context.getSchema(),\n      frag.typeCondition,\n    );\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}