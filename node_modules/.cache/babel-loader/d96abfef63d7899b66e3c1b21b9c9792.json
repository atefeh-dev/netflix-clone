{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.suggestionList = suggestionList;\n\nvar _naturalCompare = require('./naturalCompare.js');\n/**\n * Given an invalid input string and a list of valid options, returns a filtered\n * list of valid options sorted based on their similarity with the input.\n */\n\n\nfunction suggestionList(input, options) {\n  const optionsByDistance = Object.create(null);\n  const lexicalDistance = new LexicalDistance(input);\n  const threshold = Math.floor(input.length * 0.4) + 1;\n\n  for (const option of options) {\n    const distance = lexicalDistance.measure(option, threshold);\n\n    if (distance !== undefined) {\n      optionsByDistance[option] = distance;\n    }\n  }\n\n  return Object.keys(optionsByDistance).sort((a, b) => {\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);\n  });\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\n * as a single edit which helps identify mis-cased values with an edit distance\n * of 1.\n *\n * This distance can be useful for detecting typos in input or sorting\n */\n\n\nclass LexicalDistance {\n  constructor(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];\n  }\n\n  measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n\n    const optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\n\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n\n    let a = stringToArray(optionLowerCase);\n    let b = this._inputArray;\n\n    if (a.length < b.length) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength - bLength > threshold) {\n      return undefined;\n    }\n\n    const rows = this._rows;\n\n    for (let j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n\n    for (let i = 1; i <= aLength; i++) {\n      const upRow = rows[(i - 1) % 3];\n      const currentRow = rows[i % 3];\n      let smallestCell = currentRow[0] = i;\n\n      for (let j = 1; j <= bLength; j++) {\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n        let currentCell = Math.min(upRow[j] + 1, // delete\n        currentRow[j - 1] + 1, // insert\n        upRow[j - 1] + cost // substitute\n        );\n\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n          // transposition\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n\n        currentRow[j] = currentCell;\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\n\n\n      if (smallestCell > threshold) {\n        return undefined;\n      }\n    }\n\n    const distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : undefined;\n  }\n\n}\n\nfunction stringToArray(str) {\n  const strLength = str.length;\n  const array = new Array(strLength);\n\n  for (let i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n\n  return array;\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/jsutils/suggestionList.js"],"names":["Object","defineProperty","exports","value","suggestionList","_naturalCompare","require","input","options","optionsByDistance","create","lexicalDistance","LexicalDistance","threshold","Math","floor","length","option","distance","measure","undefined","keys","sort","a","b","distanceDiff","naturalCompare","constructor","_input","_inputLowerCase","toLowerCase","_inputArray","stringToArray","_rows","Array","fill","optionLowerCase","tmp","aLength","bLength","rows","j","i","upRow","currentRow","smallestCell","cost","currentCell","min","doubleDiagonalCell","str","strLength","array","charCodeAt"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.suggestionList = suggestionList;\n\nvar _naturalCompare = require('./naturalCompare.js');\n\n/**\n * Given an invalid input string and a list of valid options, returns a filtered\n * list of valid options sorted based on their similarity with the input.\n */\nfunction suggestionList(input, options) {\n  const optionsByDistance = Object.create(null);\n  const lexicalDistance = new LexicalDistance(input);\n  const threshold = Math.floor(input.length * 0.4) + 1;\n\n  for (const option of options) {\n    const distance = lexicalDistance.measure(option, threshold);\n\n    if (distance !== undefined) {\n      optionsByDistance[option] = distance;\n    }\n  }\n\n  return Object.keys(optionsByDistance).sort((a, b) => {\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0\n      ? distanceDiff\n      : (0, _naturalCompare.naturalCompare)(a, b);\n  });\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\n * as a single edit which helps identify mis-cased values with an edit distance\n * of 1.\n *\n * This distance can be useful for detecting typos in input or sorting\n */\n\nclass LexicalDistance {\n  constructor(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0),\n    ];\n  }\n\n  measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n\n    const optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\n\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n\n    let a = stringToArray(optionLowerCase);\n    let b = this._inputArray;\n\n    if (a.length < b.length) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength - bLength > threshold) {\n      return undefined;\n    }\n\n    const rows = this._rows;\n\n    for (let j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n\n    for (let i = 1; i <= aLength; i++) {\n      const upRow = rows[(i - 1) % 3];\n      const currentRow = rows[i % 3];\n      let smallestCell = (currentRow[0] = i);\n\n      for (let j = 1; j <= bLength; j++) {\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n        let currentCell = Math.min(\n          upRow[j] + 1, // delete\n          currentRow[j - 1] + 1, // insert\n          upRow[j - 1] + cost, // substitute\n        );\n\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n          // transposition\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n\n        currentRow[j] = currentCell;\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\n\n      if (smallestCell > threshold) {\n        return undefined;\n      }\n    }\n\n    const distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : undefined;\n  }\n}\n\nfunction stringToArray(str) {\n  const strLength = str.length;\n  const array = new Array(strLength);\n\n  for (let i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n\n  return array;\n}\n"]},"metadata":{},"sourceType":"script"}