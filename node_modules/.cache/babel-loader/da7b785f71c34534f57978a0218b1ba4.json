{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _definition = require('../../type/definition.js');\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\n\nfunction PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n          nodes: defNode ? [defNode, node] : node\n        }));\n      }\n    } else {\n      const allTypeNames = Object.keys({ ...definedTypes,\n        ...(schema === null || schema === void 0 ? void 0 : schema.getTypeMap())\n      });\n      const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);\n      context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type \"${typeName}\" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {\n        nodes: node.name\n      }));\n    }\n  }\n}\n\nconst defKindToExtKind = {\n  [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n  [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n  [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n  [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,\n  [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,\n  [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION\n};\n\nfunction typeToExtKind(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return _kinds.Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return _kinds.Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return _kinds.Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return _kinds.Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return _kinds.Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n\n  false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || (0, _invariant.invariant)(false, 'Unexpected kind: ' + (0, _inspect.inspect)(kind));\n  }\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"],"names":["Object","defineProperty","exports","value","PossibleTypeExtensionsRule","_didYouMean","require","_inspect","_invariant","_suggestionList","_GraphQLError","_kinds","_predicates","_definition","context","schema","getSchema","definedTypes","create","def","getDocument","definitions","isTypeDefinitionNode","name","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","typeName","defNode","existingType","getType","expectedKind","defKindToExtKind","kind","typeToExtKind","kindStr","extensionKindToTypeName","reportError","GraphQLError","nodes","allTypeNames","keys","getTypeMap","suggestedTypes","suggestionList","didYouMean","Kind","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","invariant","inspect"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nfunction PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Cannot extend non-${kindStr} type \"${typeName}\".`,\n            {\n              nodes: defNode ? [defNode, node] : node,\n            },\n          ),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = (0, _suggestionList.suggestionList)(\n        typeName,\n        allTypeNames,\n      );\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            (0, _didYouMean.didYouMean)(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\n\nconst defKindToExtKind = {\n  [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n  [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n  [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n  [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,\n  [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,\n  [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]:\n    _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return _kinds.Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return _kinds.Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return _kinds.Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return _kinds.Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return _kinds.Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected type: ' + (0, _inspect.inspect)(type),\n    );\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false ||\n        (0, _invariant.invariant)(\n          false,\n          'Unexpected kind: ' + (0, _inspect.inspect)(kind),\n        );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}