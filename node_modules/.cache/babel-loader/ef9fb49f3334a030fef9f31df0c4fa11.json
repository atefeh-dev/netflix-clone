{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.assertValidExecutionArguments = assertValidExecutionArguments;\nexports.buildExecutionContext = buildExecutionContext;\nexports.buildResolveInfo = buildResolveInfo;\nexports.defaultTypeResolver = exports.defaultFieldResolver = void 0;\nexports.execute = execute;\nexports.executeSync = executeSync;\nexports.getFieldDef = getFieldDef;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _isPromise = require('../jsutils/isPromise.js');\n\nvar _memoize = require('../jsutils/memoize3.js');\n\nvar _Path = require('../jsutils/Path.js');\n\nvar _promiseForObject = require('../jsutils/promiseForObject.js');\n\nvar _promiseReduce = require('../jsutils/promiseReduce.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _locatedError = require('../error/locatedError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _validate = require('../type/validate.js');\n\nvar _collectFields = require('./collectFields.js');\n\nvar _values = require('./values.js');\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\n\nconst collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\n\nfunction execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 || (0, _devAssert.devAssert)(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');\n  const {\n    schema,\n    document,\n    variableValues,\n    rootValue\n  } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n\n  try {\n    const {\n      operation\n    } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if ((0, _isPromise.isPromise)(result)) {\n      return result.then(data => buildResponse(data, exeContext.errors), error => {\n        exeContext.errors.push(error);\n        return buildResponse(null, exeContext.errors);\n      });\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\n\nfunction executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if ((0, _isPromise.isPromise)(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0 ? {\n    data\n  } : {\n    errors,\n    data\n  };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\n\nfunction assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || (0, _devAssert.devAssert)(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\n\nfunction buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [new _GraphQLError.GraphQLError('Must provide operation name if query contains multiple operations.')];\n          }\n\n          operation = definition;\n        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n          operation = definition;\n        }\n\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new _GraphQLError.GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new _GraphQLError.GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n\n  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n  const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n    maxErrors: 50\n  });\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,\n    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,\n    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,\n    errors: []\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {\n      nodes: operation\n    });\n  }\n\n  const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);\n  const path = undefined;\n\n  switch (operation.operation) {\n    case _ast.OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case _ast.OperationTypeNode.MUTATION:\n      return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n\n    case _ast.OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, _ref) => {\n    let [responseName, fieldNodes] = _ref;\n    const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);\n    const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result === undefined) {\n      return results;\n    }\n\n    if ((0, _isPromise.isPromise)(result)) {\n      return result.then(resolvedResult => {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);\n    const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if ((0, _isPromise.isPromise)(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n\n  return (0, _promiseForObject.promiseForObject)(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;\n  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if ((0, _isPromise.isPromise)(result)) {\n      completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n\n    if ((0, _isPromise.isPromise)(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, rawError => {\n        const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if ((0, _definition.isNonNullType)(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n\n  if ((0, _definition.isNonNullType)(returnType)) {\n    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n\n    if (completed === null) {\n      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n\n  if ((0, _definition.isListType)(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n\n  if ((0, _definition.isLeafType)(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n\n  if ((0, _definition.isAbstractType)(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n\n\n  if ((0, _definition.isObjectType)(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n\n  false || (0, _invariant.invariant)(false, 'Cannot complete value of unexpected output type: ' + (0, _inspect.inspect)(returnType));\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  if (!(0, _isIterableObject.isIterableObject)(result)) {\n    throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`);\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = (0, _Path.addPath)(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if ((0, _isPromise.isPromise)(item)) {\n        completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));\n      } else {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);\n      }\n\n      if ((0, _isPromise.isPromise)(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, rawError => {\n          const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(`Expected \\`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\\` to ` + `return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if ((0, _isPromise.isPromise)(runtimeType)) {\n    return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));\n  }\n\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\n\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n  if (runtimeTypeName == null) {\n    throw new _GraphQLError.GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, fieldNodes);\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n\n  if ((0, _definition.isObjectType)(runtimeTypeName)) {\n    throw new _GraphQLError.GraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new _GraphQLError.GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` + `value ${(0, _inspect.inspect)(result)}, received \"${(0, _inspect.inspect)(runtimeTypeName)}\".`);\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new _GraphQLError.GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, {\n      nodes: fieldNodes\n    });\n  }\n\n  if (!(0, _definition.isObjectType)(runtimeType)) {\n    throw new _GraphQLError.GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, {\n      nodes: fieldNodes\n    });\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new _GraphQLError.GraphQLError(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, {\n      nodes: fieldNodes\n    });\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if ((0, _isPromise.isPromise)(isTypeOf)) {\n      return isTypeOf.then(resolvedIsTypeOf => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(exeContext, returnType, result, path, subFieldNodes);\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new _GraphQLError.GraphQLError(`Expected value of type \"${returnType.name}\" but got: ${(0, _inspect.inspect)(result)}.`, {\n    nodes: fieldNodes\n  });\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\n\nconst defaultTypeResolver = function (value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if ((0, _isPromise.isPromise)(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\n\nexports.defaultTypeResolver = defaultTypeResolver;\n\nconst defaultFieldResolver = function (source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if ((0, _isObjectLike.isObjectLike)(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\n\nexports.defaultFieldResolver = defaultFieldResolver;\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/execution/execute.js"],"names":["Object","defineProperty","exports","value","assertValidExecutionArguments","buildExecutionContext","buildResolveInfo","defaultTypeResolver","defaultFieldResolver","execute","executeSync","getFieldDef","_devAssert","require","_inspect","_invariant","_isIterableObject","_isObjectLike","_isPromise","_memoize","_Path","_promiseForObject","_promiseReduce","_GraphQLError","_locatedError","_ast","_kinds","_definition","_introspection","_validate","_collectFields","_values","collectSubfields","memoize3","exeContext","returnType","fieldNodes","schema","fragments","variableValues","args","arguments","length","devAssert","document","rootValue","errors","operation","result","executeOperation","isPromise","then","data","buildResponse","error","push","Error","rawVariableValues","assertValidSchema","isObjectLike","_definition$name","_operation$variableDe","contextValue","operationName","fieldResolver","typeResolver","subscribeFieldResolver","create","definition","definitions","kind","Kind","OPERATION_DEFINITION","undefined","GraphQLError","name","FRAGMENT_DEFINITION","variableDefinitions","coercedVariableValues","getVariableValues","maxErrors","coerced","rootType","getRootType","nodes","rootFields","collectFields","selectionSet","path","OperationTypeNode","QUERY","executeFields","MUTATION","executeFieldsSerially","SUBSCRIPTION","parentType","sourceValue","fields","promiseReduce","entries","results","responseName","fieldPath","addPath","executeField","resolvedResult","containsPromise","promiseForObject","source","_fieldDef$resolve","fieldDef","type","resolveFn","resolve","info","getArgumentValues","completed","resolved","completeValue","rawError","locatedError","pathToArray","handleFieldError","fieldName","isNonNullType","ofType","isListType","completeListValue","isLeafType","completeLeafValue","isAbstractType","completeAbstractValue","isObjectType","completeObjectValue","invariant","inspect","isIterableObject","itemType","completedResults","Array","from","item","index","itemPath","completedItem","Promise","all","serializedResult","serialize","_returnType$resolveTy","resolveTypeFn","resolveType","runtimeType","resolvedRuntimeType","ensureValidRuntimeType","runtimeTypeName","getType","isSubType","subFieldNodes","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","i","isTypeOfResult","isTypeOfResults","property","fieldNode","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","getFields"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.assertValidExecutionArguments = assertValidExecutionArguments;\nexports.buildExecutionContext = buildExecutionContext;\nexports.buildResolveInfo = buildResolveInfo;\nexports.defaultTypeResolver = exports.defaultFieldResolver = void 0;\nexports.execute = execute;\nexports.executeSync = executeSync;\nexports.getFieldDef = getFieldDef;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _isPromise = require('../jsutils/isPromise.js');\n\nvar _memoize = require('../jsutils/memoize3.js');\n\nvar _Path = require('../jsutils/Path.js');\n\nvar _promiseForObject = require('../jsutils/promiseForObject.js');\n\nvar _promiseReduce = require('../jsutils/promiseReduce.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _locatedError = require('../error/locatedError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _validate = require('../type/validate.js');\n\nvar _collectFields = require('./collectFields.js');\n\nvar _values = require('./values.js');\n\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\nconst collectSubfields = (0, _memoize.memoize3)(\n  (exeContext, returnType, fieldNodes) =>\n    (0, _collectFields.collectSubfields)(\n      exeContext.schema,\n      exeContext.fragments,\n      exeContext.variableValues,\n      returnType,\n      fieldNodes,\n    ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nfunction execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    (0, _devAssert.devAssert)(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if ((0, _isPromise.isPromise)(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nfunction executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if ((0, _isPromise.isPromise)(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nfunction assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || (0, _devAssert.devAssert)(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    (0, _isObjectLike.isObjectLike)(rawVariableValues) ||\n    (0, _devAssert.devAssert)(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nfunction buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new _GraphQLError.GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [\n        new _GraphQLError.GraphQLError(\n          `Unknown operation named \"${operationName}\".`,\n        ),\n      ];\n    }\n\n    return [new _GraphQLError.GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = (0, _values.getVariableValues)(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors: 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new _GraphQLError.GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = (0, _collectFields.collectFields)(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case _ast.OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case _ast.OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case _ast.OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return (0, _promiseReduce.promiseReduce)(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if ((0, _isPromise.isPromise)(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);\n    const result = executeField(\n      exeContext,\n      parentType,\n      sourceValue,\n      fieldNodes,\n      fieldPath,\n    );\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if ((0, _isPromise.isPromise)(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return (0, _promiseForObject.promiseForObject)(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = (0, _values.getArgumentValues)(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if ((0, _isPromise.isPromise)(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if ((0, _isPromise.isPromise)(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = (0, _locatedError.locatedError)(\n          rawError,\n          fieldNodes,\n          (0, _Path.pathToArray)(path),\n        );\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = (0, _locatedError.locatedError)(\n      rawError,\n      fieldNodes,\n      (0, _Path.pathToArray)(path),\n    );\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nfunction buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if ((0, _definition.isNonNullType)(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if ((0, _definition.isNonNullType)(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if ((0, _definition.isListType)(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if ((0, _definition.isLeafType)(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if ((0, _definition.isAbstractType)(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if ((0, _definition.isObjectType)(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Cannot complete value of unexpected output type: ' +\n        (0, _inspect.inspect)(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!(0, _isIterableObject.isIterableObject)(result)) {\n    throw new _GraphQLError.GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = (0, _Path.addPath)(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if ((0, _isPromise.isPromise)(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if ((0, _isPromise.isPromise)(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = (0, _locatedError.locatedError)(\n            rawError,\n            fieldNodes,\n            (0, _Path.pathToArray)(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = (0, _locatedError.locatedError)(\n        rawError,\n        fieldNodes,\n        (0, _Path.pathToArray)(itemPath),\n      );\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${(0, _inspect.inspect)(returnType)}.serialize(${(0,\n      _inspect.inspect)(result)})\\` to ` +\n        `return non-nullable value, returned: ${(0, _inspect.inspect)(\n          serializedResult,\n        )}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if ((0, _isPromise.isPromise)(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if ((0, _definition.isObjectType)(runtimeTypeName)) {\n    throw new _GraphQLError.GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${(0, _inspect.inspect)(result)}, received \"${(0,\n        _inspect.inspect)(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!(0, _definition.isObjectType)(runtimeType)) {\n    throw new _GraphQLError.GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new _GraphQLError.GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if ((0, _isPromise.isPromise)(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new _GraphQLError.GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${(0,\n    _inspect.inspect)(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nconst defaultTypeResolver = function (value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (\n    (0, _isObjectLike.isObjectLike)(value) &&\n    typeof value.__typename === 'string'\n  ) {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if ((0, _isPromise.isPromise)(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexports.defaultTypeResolver = defaultTypeResolver;\n\nconst defaultFieldResolver = function (source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if ((0, _isObjectLike.isObjectLike)(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexports.defaultFieldResolver = defaultFieldResolver;\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === _introspection.SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.SchemaMetaFieldDef;\n  } else if (\n    fieldName === _introspection.TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.TypeMetaFieldDef;\n  } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n"]},"metadata":{},"sourceType":"script"}