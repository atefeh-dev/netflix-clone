{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.astFromValue = astFromValue;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _scalars = require('../type/scalars.js');\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Unknown       | Enum Value           |\n * | null          | NullValue            |\n *\n */\n\n\nfunction astFromValue(value, type) {\n  if ((0, _definition.isNonNullType)(type)) {\n    const astValue = astFromValue(value, type.ofType);\n\n    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n\n  if (value === null) {\n    return {\n      kind: _kinds.Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n\n    if ((0, _isIterableObject.isIterableObject)(value)) {\n      const valuesNodes = [];\n\n      for (const item of value) {\n        const itemNode = astFromValue(item, itemType);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n\n      return {\n        kind: _kinds.Kind.LIST,\n        values: valuesNodes\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (!(0, _isObjectLike.isObjectLike)(value)) {\n      return null;\n    }\n\n    const fieldNodes = [];\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: _kinds.Kind.OBJECT_FIELD,\n          name: {\n            kind: _kinds.Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n\n    return {\n      kind: _kinds.Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    const serialized = type.serialize(value);\n\n    if (serialized == null) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: _kinds.Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n\n    if (typeof serialized === 'number' && Number.isFinite(serialized)) {\n      const stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: _kinds.Kind.INT,\n        value: stringNum\n      } : {\n        kind: _kinds.Kind.FLOAT,\n        value: stringNum\n      };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if ((0, _definition.isEnumType)(type)) {\n        return {\n          kind: _kinds.Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n\n      if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: _kinds.Kind.INT,\n          value: serialized\n        };\n      }\n\n      return {\n        kind: _kinds.Kind.STRING,\n        value: serialized\n      };\n    }\n\n    throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || (0, _invariant.invariant)(false, 'Unexpected input type: ' + (0, _inspect.inspect)(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/astFromValue.js"],"names":["Object","defineProperty","exports","value","astFromValue","_inspect","require","_invariant","_isIterableObject","_isObjectLike","_kinds","_definition","_scalars","type","isNonNullType","astValue","ofType","kind","Kind","NULL","undefined","isListType","itemType","isIterableObject","valuesNodes","item","itemNode","push","LIST","values","isInputObjectType","isObjectLike","fieldNodes","field","getFields","fieldValue","name","OBJECT_FIELD","NAME","OBJECT","fields","isLeafType","serialized","serialize","BOOLEAN","Number","isFinite","stringNum","String","integerStringRegExp","test","INT","FLOAT","isEnumType","ENUM","GraphQLID","STRING","TypeError","inspect","invariant"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.astFromValue = astFromValue;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _scalars = require('../type/scalars.js');\n\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Unknown       | Enum Value           |\n * | null          | NullValue            |\n *\n */\nfunction astFromValue(value, type) {\n  if ((0, _definition.isNonNullType)(type)) {\n    const astValue = astFromValue(value, type.ofType);\n\n    if (\n      (astValue === null || astValue === void 0 ? void 0 : astValue.kind) ===\n      _kinds.Kind.NULL\n    ) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n  if (value === null) {\n    return {\n      kind: _kinds.Kind.NULL,\n    };\n  } // undefined\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n\n    if ((0, _isIterableObject.isIterableObject)(value)) {\n      const valuesNodes = [];\n\n      for (const item of value) {\n        const itemNode = astFromValue(item, itemType);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n\n      return {\n        kind: _kinds.Kind.LIST,\n        values: valuesNodes,\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (!(0, _isObjectLike.isObjectLike)(value)) {\n      return null;\n    }\n\n    const fieldNodes = [];\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: _kinds.Kind.OBJECT_FIELD,\n          name: {\n            kind: _kinds.Kind.NAME,\n            value: field.name,\n          },\n          value: fieldValue,\n        });\n      }\n    }\n\n    return {\n      kind: _kinds.Kind.OBJECT,\n      fields: fieldNodes,\n    };\n  }\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    const serialized = type.serialize(value);\n\n    if (serialized == null) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: _kinds.Kind.BOOLEAN,\n        value: serialized,\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n    if (typeof serialized === 'number' && Number.isFinite(serialized)) {\n      const stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum)\n        ? {\n            kind: _kinds.Kind.INT,\n            value: stringNum,\n          }\n        : {\n            kind: _kinds.Kind.FLOAT,\n            value: stringNum,\n          };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if ((0, _definition.isEnumType)(type)) {\n        return {\n          kind: _kinds.Kind.ENUM,\n          value: serialized,\n        };\n      } // ID types can use Int literals.\n\n      if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: _kinds.Kind.INT,\n          value: serialized,\n        };\n      }\n\n      return {\n        kind: _kinds.Kind.STRING,\n        value: serialized,\n      };\n    }\n\n    throw new TypeError(\n      `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`,\n    );\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected input type: ' + (0, _inspect.inspect)(type),\n    );\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"]},"metadata":{},"sourceType":"script"}