{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.buildSchema = buildSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _parser = require('../language/parser.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _validate = require('../validation/validate.js');\n\nvar _extendSchema = require('./extendSchema.js');\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\n\n\nfunction buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    (0, _validate.assertValidSDL)(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  const config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [...config.directives, // If specified directives were not explicitly declared, add them.\n  ..._directives.specifiedDirectives.filter(stdDirective => config.directives.every(directive => directive.name !== stdDirective.name))];\n  return new _schema.GraphQLSchema({ ...config,\n    directives\n  });\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nfunction buildSchema(source, options) {\n  const document = (0, _parser.parse)(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables\n  });\n  return buildASTSchema(document, {\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/utilities/buildASTSchema.js"],"names":["Object","defineProperty","exports","value","buildASTSchema","buildSchema","_devAssert","require","_kinds","_parser","_directives","_schema","_validate","_extendSchema","documentAST","options","kind","Kind","DOCUMENT","devAssert","assumeValid","assumeValidSDL","assertValidSDL","emptySchemaConfig","description","undefined","types","directives","extensions","create","extensionASTNodes","config","extendSchemaImpl","astNode","type","name","query","mutation","subscription","specifiedDirectives","filter","stdDirective","every","directive","GraphQLSchema","source","document","parse","noLocation","allowLegacyFragmentVariables"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.buildASTSchema = buildASTSchema;\nexports.buildSchema = buildSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _parser = require('../language/parser.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _validate = require('../validation/validate.js');\n\nvar _extendSchema = require('./extendSchema.js');\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nfunction buildASTSchema(documentAST, options) {\n  (documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT) ||\n    (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    (0, _validate.assertValidSDL)(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false,\n  };\n  const config = (0, _extendSchema.extendSchemaImpl)(\n    emptySchemaConfig,\n    documentAST,\n    options,\n  );\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [\n    ...config.directives, // If specified directives were not explicitly declared, add them.\n    ..._directives.specifiedDirectives.filter((stdDirective) =>\n      config.directives.every(\n        (directive) => directive.name !== stdDirective.name,\n      ),\n    ),\n  ];\n  return new _schema.GraphQLSchema({ ...config, directives });\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nfunction buildSchema(source, options) {\n  const document = (0, _parser.parse)(source, {\n    noLocation:\n      options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables:\n      options === null || options === void 0\n        ? void 0\n        : options.allowLegacyFragmentVariables,\n  });\n  return buildASTSchema(document, {\n    assumeValidSDL:\n      options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  });\n}\n"]},"metadata":{},"sourceType":"script"}