{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _naturalCompare = require('../../jsutils/naturalCompare.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\n\n\nfunction FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = (0, _didYouMean.didYouMean)('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new _GraphQLError.GraphQLError(`Cannot query field \"${fieldName}\" on type \"${type.name}\".` + suggestion, {\n            nodes: node\n          }));\n        }\n      }\n    }\n\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!(0, _definition.isAbstractType)(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes].sort((typeA, typeB) => {\n    // Suggest both interface and object types based on how common they are.\n    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);\n  }).map(x => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}","map":{"version":3,"sources":["/home/atefeh/Documents/my-project/netflix/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"],"names":["Object","defineProperty","exports","value","FieldsOnCorrectTypeRule","_didYouMean","require","_naturalCompare","_suggestionList","_GraphQLError","_definition","context","Field","node","type","getParentType","fieldDef","getFieldDef","schema","getSchema","fieldName","name","suggestion","didYouMean","getSuggestedTypeNames","getSuggestedFieldNames","reportError","GraphQLError","nodes","isAbstractType","suggestedTypes","Set","usageCount","create","possibleType","getPossibleTypes","getFields","add","possibleInterface","getInterfaces","_usageCount$possibleI","sort","typeA","typeB","usageCountDiff","isInterfaceType","isSubType","naturalCompare","map","x","isObjectType","possibleFieldNames","keys","suggestionList"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,uBAAR,GAAkCA,uBAAlC;;AAEA,IAAIC,WAAW,GAAGC,OAAO,CAAC,6BAAD,CAAzB;;AAEA,IAAIC,eAAe,GAAGD,OAAO,CAAC,iCAAD,CAA7B;;AAEA,IAAIE,eAAe,GAAGF,OAAO,CAAC,iCAAD,CAA7B;;AAEA,IAAIG,aAAa,GAAGH,OAAO,CAAC,6BAAD,CAA3B;;AAEA,IAAII,WAAW,GAAGJ,OAAO,CAAC,0BAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,uBAAT,CAAiCO,OAAjC,EAA0C;AACxC,SAAO;AACLC,IAAAA,KAAK,CAACC,IAAD,EAAO;AACV,YAAMC,IAAI,GAAGH,OAAO,CAACI,aAAR,EAAb;;AAEA,UAAID,IAAJ,EAAU;AACR,cAAME,QAAQ,GAAGL,OAAO,CAACM,WAAR,EAAjB;;AAEA,YAAI,CAACD,QAAL,EAAe;AACb;AACA,gBAAME,MAAM,GAAGP,OAAO,CAACQ,SAAR,EAAf;AACA,gBAAMC,SAAS,GAAGP,IAAI,CAACQ,IAAL,CAAUlB,KAA5B,CAHa,CAGsB;;AAEnC,cAAImB,UAAU,GAAG,CAAC,GAAGjB,WAAW,CAACkB,UAAhB,EACf,8BADe,EAEfC,qBAAqB,CAACN,MAAD,EAASJ,IAAT,EAAeM,SAAf,CAFN,CAAjB,CALa,CAQV;;AAEH,cAAIE,UAAU,KAAK,EAAnB,EAAuB;AACrBA,YAAAA,UAAU,GAAG,CAAC,GAAGjB,WAAW,CAACkB,UAAhB,EACXE,sBAAsB,CAACX,IAAD,EAAOM,SAAP,CADX,CAAb;AAGD,WAdY,CAcX;;;AAEFT,UAAAA,OAAO,CAACe,WAAR,CACE,IAAIjB,aAAa,CAACkB,YAAlB,CACG,uBAAsBP,SAAU,cAAaN,IAAI,CAACO,IAAK,IAAxD,GACEC,UAFJ,EAGE;AACEM,YAAAA,KAAK,EAAEf;AADT,WAHF,CADF;AASD;AACF;AACF;;AAlCI,GAAP;AAoCD;AACD;AACA;AACA;AACA;AACA;;;AAEA,SAASW,qBAAT,CAA+BN,MAA/B,EAAuCJ,IAAvC,EAA6CM,SAA7C,EAAwD;AACtD,MAAI,CAAC,CAAC,GAAGV,WAAW,CAACmB,cAAhB,EAAgCf,IAAhC,CAAL,EAA4C;AAC1C;AACA,WAAO,EAAP;AACD;;AAED,QAAMgB,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AACA,QAAMC,UAAU,GAAGhC,MAAM,CAACiC,MAAP,CAAc,IAAd,CAAnB;;AAEA,OAAK,MAAMC,YAAX,IAA2BhB,MAAM,CAACiB,gBAAP,CAAwBrB,IAAxB,CAA3B,EAA0D;AACxD,QAAI,CAACoB,YAAY,CAACE,SAAb,GAAyBhB,SAAzB,CAAL,EAA0C;AACxC;AACD,KAHuD,CAGtD;;;AAEFU,IAAAA,cAAc,CAACO,GAAf,CAAmBH,YAAnB;AACAF,IAAAA,UAAU,CAACE,YAAY,CAACb,IAAd,CAAV,GAAgC,CAAhC;;AAEA,SAAK,MAAMiB,iBAAX,IAAgCJ,YAAY,CAACK,aAAb,EAAhC,EAA8D;AAC5D,UAAIC,qBAAJ;;AAEA,UAAI,CAACF,iBAAiB,CAACF,SAAlB,GAA8BhB,SAA9B,CAAL,EAA+C;AAC7C;AACD,OAL2D,CAK1D;;;AAEFU,MAAAA,cAAc,CAACO,GAAf,CAAmBC,iBAAnB;AACAN,MAAAA,UAAU,CAACM,iBAAiB,CAACjB,IAAnB,CAAV,GACE,CAAC,CAACmB,qBAAqB,GAAGR,UAAU,CAACM,iBAAiB,CAACjB,IAAnB,CAAnC,MACC,IADD,IACSmB,qBAAqB,KAAK,KAAK,CADxC,GAEGA,qBAFH,GAGG,CAHJ,IAGS,CAJX;AAKD;AACF;;AAED,SAAO,CAAC,GAAGV,cAAJ,EACJW,IADI,CACC,CAACC,KAAD,EAAQC,KAAR,KAAkB;AACtB;AACA,UAAMC,cAAc,GAAGZ,UAAU,CAACW,KAAK,CAACtB,IAAP,CAAV,GAAyBW,UAAU,CAACU,KAAK,CAACrB,IAAP,CAA1D;;AAEA,QAAIuB,cAAc,KAAK,CAAvB,EAA0B;AACxB,aAAOA,cAAP;AACD,KANqB,CAMpB;;;AAEF,QACE,CAAC,GAAGlC,WAAW,CAACmC,eAAhB,EAAiCH,KAAjC,KACAxB,MAAM,CAAC4B,SAAP,CAAiBJ,KAAjB,EAAwBC,KAAxB,CAFF,EAGE;AACA,aAAO,CAAC,CAAR;AACD;;AAED,QACE,CAAC,GAAGjC,WAAW,CAACmC,eAAhB,EAAiCF,KAAjC,KACAzB,MAAM,CAAC4B,SAAP,CAAiBH,KAAjB,EAAwBD,KAAxB,CAFF,EAGE;AACA,aAAO,CAAP;AACD;;AAED,WAAO,CAAC,GAAGnC,eAAe,CAACwC,cAApB,EAAoCL,KAAK,CAACrB,IAA1C,EAAgDsB,KAAK,CAACtB,IAAtD,CAAP;AACD,GAxBI,EAyBJ2B,GAzBI,CAyBCC,CAAD,IAAOA,CAAC,CAAC5B,IAzBT,CAAP;AA0BD;AACD;AACA;AACA;AACA;;;AAEA,SAASI,sBAAT,CAAgCX,IAAhC,EAAsCM,SAAtC,EAAiD;AAC/C,MACE,CAAC,GAAGV,WAAW,CAACwC,YAAhB,EAA8BpC,IAA9B,KACA,CAAC,GAAGJ,WAAW,CAACmC,eAAhB,EAAiC/B,IAAjC,CAFF,EAGE;AACA,UAAMqC,kBAAkB,GAAGnD,MAAM,CAACoD,IAAP,CAAYtC,IAAI,CAACsB,SAAL,EAAZ,CAA3B;AACA,WAAO,CAAC,GAAG5B,eAAe,CAAC6C,cAApB,EAAoCjC,SAApC,EAA+C+B,kBAA/C,CAAP;AACD,GAP8C,CAO7C;;;AAEF,SAAO,EAAP;AACD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _naturalCompare = require('../../jsutils/naturalCompare.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nfunction FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = (0, _didYouMean.didYouMean)(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = (0, _didYouMean.didYouMean)(\n              getSuggestedFieldNames(type, fieldName),\n            );\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!(0, _definition.isAbstractType)(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (\n        (0, _definition.isInterfaceType)(typeA) &&\n        schema.isSubType(typeA, typeB)\n      ) {\n        return -1;\n      }\n\n      if (\n        (0, _definition.isInterfaceType)(typeB) &&\n        schema.isSubType(typeB, typeA)\n      ) {\n        return 1;\n      }\n\n      return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (\n    (0, _definition.isObjectType)(type) ||\n    (0, _definition.isInterfaceType)(type)\n  ) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"script"}